# 1. UNIX 시스템의 개요

## UNIX 아키텍처

운영체제: 컴퓨터의 하드웨어 자원들을 제어하고 프로그램이 실행될 환경을 제공하는 소프트웨어이고 이런걸 커널이라고 부른다. </br>
커널이라고 하는 이유는 그런 소프트웨어가 비교적 작으며 운영 환경의 핵심부를 차지하고 있기 때문이다.

커널에 대한 인터페이스는 시스템 호출이라고 부르는 하나의 소프트웨어 계층이다. </br>
공통적으로 쓰이는 함수들을 모은 라이브러리들은 이 시스템 호출 인터페이스를 기초로 해서 만들어지는데, 응용 프로그램이 시스템 호출을 사용하는 것도 가능하다. </br>
셸은 다른 응용 프로그램을 실행하기 위한 하나의 인터페이스를 제공하는 특별한 응용 프로그램이다.

좀 더 넓은 의미에서는, 커널뿐만 아니라 컴퓨터를 유용하게 만들고 컴퓨터에 개성을 부여하는 다른 모든 소프트웨어까지 포괄한 것을 운영체제라고 한다. </br>
여기서 다른 소프트웨어는 시스템 유틸리티, 응용 프로그램, 셸, 공통 함수들의 라이브러리 등이 포함됨.

## 로그인

### 로그인 이름

사용자가 UNIX 시스템에 로그인할 때에는 로그인 이름과 패스워드를 입력한다. </br>
시스템은 패스워드 파일(보통은 /etc/passwd 파일)에 그 로그인 이름이 있는지 살펴본다. </br>
패스워드 파일의 한 줄은 콜론(:)으로 구분된 일곱 개의 필드들로 구성되는데, 일곱 필드들은 차례로 로그인 이름, 암호화된 패스워드, 사용자 ID, 그룹 ID, 주석 필드, 홈 디렉토리(/home/sar), 셸 프로그램(/bin/ksh)이다.

sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh

현대적인 운영체제들은 모두 암호화된 패스워드 부분을 다른 어떤 파일에 따로 보관함.

### 셸

로그인이 성공적으로 이루어지면 일반적으로 약간의 시스템 정보 메시지가 나타나고, 셸 프로그램에 명령을 입력할 수 있게 된다. </br>
셸은 사용자의 입력을 읽고 명령들을 수행하는 명령줄 해석기이다. 셸에 주어지는 사용자 입력은 대게 사람이 터미널에서 입력한 것이지만 경우에 따라서는 셸 스크립트라고 부르는 파일에서 읽을 것일수도 있다.

UNIX 시스템에서 흔히 쓰이는 셸

| 이름 | 경로 | FreeBSD 5.2.1 | Linux 2.4.22 | Mac OS X 10.3 | Solaris 9 |
| :--: | :--: | :--: | :--: | :--: | :--: |
| Bourne 셸 | /bin/sh | | bash로 링크됨 | bash로 링크됨 | |
| Bourne-again 셸 | /bin/bash | 선택적 tcsh로 링크됨 | | | 
| C 셸 | /bin/csh | 선택적 tcsh로 링크됨 | tcsh로 링크됨 | tcsh로 링크됨 | |
| Korn 셸 | /bin/ksh | 선택적 tcsh로 링크됨 | tcsh로 링크됨 | tcsh로 링크됨 | |
| TENEX C 셸 | /bin/tcsh | | | | |

시스템은 패스워드 파일의 해당 사용자 항목의 마지막 필드를 보고 어떤 셸을 실행할 것인지 결정한다. 

## 파일과 디렉토리

### 파일 시스템

UNIX 파일 시스템은 디렉토리들과 파일들을 계통적으로 배치한 것. </br>
UNIX 파일 시스템의 모든 항목은 이름이 /인 디렉토리에서 시작한다. 이 디렉토리를 root 디렉토리라고 부른다.

디렉토리는 디렉토리 항목들을 담은 하나의 파일이다. </br>
디렉토리의 각 항목은 해당 파일의 이름과 그 파일의 특성들을 서술하는 정보를 담은 구조체로 구성된다. </br>
파일의 특성들은 파일의 종류, 파일의 크기, 파일의 소유자, 파일에 대한 권한, 파일이 마지막으로 수정된 일시 등이 있다. </br>
stat 함수와 fstat 함수는 파일의 모든 특성을 담은 정보 구조체를 돌려준다.

### 파일 이름

디렉토리 안의 이름들을 파일 이름이라 한다. </br>
파일 이름에 사용하지 못하는 문자는 슬래시(/)와 널(null)이다. 인쇄 가능한 문자들만 파일 이름에 사용하는 것이 바람직하다. </br> 
슬래시는 경로 이름을 구성하는 파일 이름들을 구분하는 용도로 쓰이고, 널 문자는 경로 이름의 끝을 표시하는 용도로 쓰인다. </br>

새 디렉토리가 생성될 때 두개의 파일 이름이 자동으로 만들어진다. 도트(.)는 현재 디렉토리, 도트-도트(..)는 부모-디렉토리를 지칭함. </br>
오늘날 쓰이는 UNIX 파일 시스템은 255자 길이의 파일 이름을 지원함.

### 경로 이름

여러 개의 파일 이름들을 슬래시로 연결한 것을 경로 이름이라 한다. </br>
경로 이름의 첫 글자가 슬래시일 수도 있는데, 그런 경로 이름을 절대 경로 이름이라고 한다. </br>
첫 글자가 슬래시가 아닌 경로 이름은 상대 경로 이름이다. 상대 경로 이름은 현재 디렉토리에 상대적인 파일을 지칭하는 데 쓰인다. </br>
파일 시스템의 루트에 대한 경로 이름, 즉 /은 파일 이름이 없는 특별한 형태의 절대 경로 이름이다.

c컴파일러를 실행하는 명령은 cc이다. GNU 컴파일 시스템을 갖춘 시스템의 경우 C 컴파일러는 gcc이다. cc가 gcc로 링크되어 있는 경우도 있다.

(example01.c)
main 함수의 선언은 ISO C가 지원하는 스타일을 사용. </br>
프로그램은 명령줄로부터 하나의 인수를 취한다. 바로 argv[1]이다. 이 인수는 나열할 디렉토리의 이름으로 쓰임. </br>
디렉토리 항목의 실제 형식은 구체적인 UNIX 시스템마다 다를 수 있기 때문에 opendir, readdir, closedir 같은 표준 함수들을 이용해 디렉토리를 조작함. </br>
opendir 함수는 DIR 구조체에 대한 포인터를 돌려줌. </br>
프로그램은 오류 처리를 위해 err_sys와 err_quit라는 함수를 사용한다. err_sys 함수는 발생한 오류의 종류를 설명해주는 메시지를 출력하는데 쓰인다. </br>
프로그램은 작업을 마친 후 인수를 0으로 해서 exit 함수를 호출한다.

### 작업 디렉토리

모든 프로세스는 작업 디렉토리를 가진다. 작업 디렉토리를 현재 작업 디렉토리라고도 한다. 프로세스 안에서 chdir 함수를 이용해 작업 디렉토리를 변경하는 것도 가능함. </br>
작업 디렉토리는 상대 경로이름의 기준이 된다. </br>

### 홈 디렉토리

사용자가 시스템에 로그인하면 사용자의 홈 디렉토리가 작업 디렉토리로 설정된다.

## 입력과 출력

### 파일 서술자

특정 프로세스가 접근하는 파일드을 식별하기 위해 커널이 사용하는 값. 보통은 음이 아닌 작은 정수이다. </br>
프로세스가 기존 파일을 열거나 새 파일을 생성하면 커널은 해당 파일에 대한 서술자를 돌려준다. </br>
프로세스는 그 서술자를 이용해서 파일을 읽거나 쓴다.

### 표준 입력, 표준 출력, 표준 오류

관례적으로, 모든 셸은 새 프로그램을 실행할 때마다 표준 입력, 표준 출력, 표준 오류를 위한 파일 서술자들을 연다. </br>
대부분의 셸은 새 서술자들 중 일부 또는 전부를 임의의 파일로 재지정하는 수단을 제공한다.

(example02.c)
<unistd.h>에 정의되어 있는 상수 STDIN_FILENO와 STDOUT_FILENO는 표준 입력과 표준 출력을 위한 파일 서술자들이다. </br>
이 상수들의 실제 값은 일반적으로 0과 1이지만, 수치 값을 직접 사용하는 대신 이 상수 이름들을 사용하는 것이 이식성에 도움 된다.
read 함수는 읽은 바이트들의 개수를 돌려준다. 프로그램은 그 개수만큼의 바이트를 표준 출력에 기록한다. </br>
입력 파일의 끝에 도달하면 read 함수는 0을 돌려주며, 그러면 프로그램이 끝남. 오류가 발생하면 read는 -1을 돌려준다. </br>
대부분의 시스템 함수들은 오류 발생시 -1을 돌려준다.

### 표준 I/O 함수들

표준 I/O 함수들은 비버퍼링 방식 I/O 함수들에 대한 버퍼링 방식 인터페이스를 제공한다. </br>
표준 I/O 함수들을 이용하면 BUFFSIZE 상수 같은 최적의 버퍼 크기를 고민할 필요가 없다. </br>
표준 I/O 함수들의 또다른 장점은 입력을 줄 단위로 처리하기 때문에 사용하기가 더 쉽다. </br>
표준 I/O 라이브러리는 라이브러리가 사용하는 버퍼링 방식을 사용자가 제어할 수 있는 함수들도 제공함. </br>

가장 흔히 쓰이는 표준 I/O 함수는 printf이다. printf를 호출하는 프로그램은 항상 <stdio.h>를 포함해야 한다.

## 프로그램과 프로세스

### 프로그램

디스크의 디렉토리에 있는 실행 파일이다. 여섯가지 exec 함수들 중 하나를 호출하면 커널은 실행파일의 내용을 메모리로 읽어 들여서 실행한다. </br>

### 프로세스와 프로세스 ID

프로그램의 한 실행 인스턴스를 프로세스라고 한다. 실행되고 있는 프로그램을 태스크(task)라고 부르는 운영체제도 있다. </br>
UNIX System은 모든 프로세스가 각자 하나의 고유한 수치 식별자를 가짐을 보장하는데, 그러한 식별자를 프로세스 ID라고 부른다. 프로세스 ID는 항상 음이 아닌 정수이다.

(example03.c)
getpid 함수를 호출해 자신의 프로세스 ID를 얻는다.

### 프로세스 제어

프로세스 제어에 쓰이는 기본적인 함수는 fork, exec, waitpid이다.

(example04.c)
표준 I/O 함수 fgets를 이용해서 표준 입력에서 한 줄의 텍스트를 읽는다. 사용자가 한 줄의 첫 문자로 파일 끝 문자를 입력하면 fgets는 널 포인터를 반환한다. </br>
fgets가 돌려주는 각 줄은 새줄 문자 하나와 널 바이트 하나로 끝난다. </br>
fork를 호출해서 새 프로세스를 생성한다. 호출한 프로세스를 부모 프로세스라고 부르고, 새로 생성된 프로세스를 자식 프로세스라고 한다. </br>
부모가 호출한 fork는 새 프로세스의 ID를 돌려준다. 자식이 호출한 fork는 0을 돌려준다. </br>
자식 프로세스에서는 표준 입력으로 읽은 명령을 execlp 함수를 이용해서 실행한다. 이 함수를 호출하면 자식 프로세스는 새 프로그램 파일의 이미지로 대체된다. </br>
이런 fork-exec 호출 조합은 일부 운영체제에서 새 프로세스의 파생이라고 부르는것에 해당. </br>
자식 프로세스가 execlp를 호출해서 새 프로그램 파일을 실행하므로, 부모는 자식이 종료되길 기다려야 한다. 이를 위해 부모 프로세스는 waitpid 함수를 호출한다. </br>
이 프로그램의 한계는 실행할 명령에 대한 인수들을 전달할 수 없다는 점이다.

### 스레드와 스레드 ID

일반적으로 하나의 프로세스는 단 하나의 제어 가닥을 가진다. 그러한 제어 가닥을 스레드라고 부른다. </br>
스레드는 한 시점에서 실행되는 기계어 명령들의 한 집합이다. </br>
한 프로세스 안의 모든 스레드는 동일한 주소 공간, 파일 서술자들 그리고 프로세스 관련 특성들을 공유한다. </br>
스택은 스레드마다 존재하나, 한 스레드가 프로세스의 다른 스레드의 스택에 접근하는 것도 가능하다. </br>
프로세스처럼 스레드들도 ID를 통해서 식별한다. 그러나 스레드 ID들은 해당 프로세스의 범위안에서만 유효하다. 즉, 한 프로세스의 한 스레드의 ID가 다른 프로세스에게는 의미가 없다.

## 오류 처리

대체로 UNIX System 함수들은 함수 실행 도중 오류가 발생했다면 음의 값을 돌려준다. 또한 오류에 대한 추가적인 정보를 뜻하는 값을 errno라는 정수 개체에 설정하는 경우도 많다. </br>
errno에는 주의해야 할 규칙이 두 가지가 있는데, 첫째로, 한 루틴에서 오류가 발생하지 않았다면 errno의 값이 해제되는 일은 결코 없다. 따라서 함수가 오류를 뜻하는 값을 반환한 경우에만 errno의 값을 조사해야 한다. </br>
둘째로, 어떤 함수도 errno를 0으로 설정하지는 않으며, <errno.h>에 정의된 상수들 중 값이 0인 것은 없다.
char *strerror(int errnum); : errnum의 값에 해당하는 오류 메시지 문자열을 가리키는 포인터를 돌려준다. </br>
void perror(const char *msg); : errno의 현재 값에 해당하는 오류 메시지를 표준 오류 스트림에 출력한다. </br>
이 함수는 msg가 가리키는 문자열과 콜론 하나, 빈칸 하나를 출력하고, errno 값에 해당하는 오류 메시지를 출력하고, 마지막으로 새줄 문자를 출력한다.

### 오류 복구

<errno.h>에 정의된 오류들은 크게 치명적 오류와 비치명적 오류로 나뉜다. </br>
치명적 오류는 복구 작용이 없는 오류이다. 이런 오류에 대해서는 그저 오류 메시지를 사용자의 화면에 표시하거나 로그 파일에 기록한 후 프로그램을 종료하는 것 외에는 할 수 있는 일이 없다. </br>
비치명적 오류는 좀 더 안정적으로 처리하는 것이 가능할 때가 많다. 자원 부족같은 대부분의 비치명적 오류들은 일시적인 성격을 지니며, 시스템의 활동이 적은 경우에는 발생하지 않기도 한다. </br>
자원 관련 치명적 오류에 대한 전형적인 오류 복구 방식은 잠시 시간을 둔 후에 다시 시도하는 것이다.

## 사용자 식별

### 사용자 ID

시스템은 패스워드 파일의 사용자 항목에 있는 사용자 ID 수치 값을 이용해서 해당 사용자를 식별한다. </br>
이 사용자 ID는 시스템 관리자가 사용자에게 로그인 이름을 배정할 때 함께 배정하는 것이며 사용자가 스스로 변경하지는 못한다. </br>
사용자 ID가 0인 사용자를 루트 또는 슈퍼 사용자라고 부른다. 일반적으로 슈퍼 사용자 패스워드 파일 항목의 로그인 이름은 root이다. 그리고 이 사용자의 특별한 권한들을 슈퍼 사용자 특권이라고 부른다.

### 그룹 ID

패스워드 파일의 사용자 항목에는 해당 사용자의 수치적 그룹 ID도 들어 있다. 이 ID 역시 시스템 관리자가 로그인 이름을 배정할 때 배정한다. </br>
일반적으로 패스워드 파일에는 동일한 그룹 ID가 지정된 항목들이 여러개 존재한다. 즉, 여러 사용자가 동일한 그룹 ID를 가질 수 있는 것이다. </br>
시스템은 패스워드 파일을 통해서 로그인 이름과 사용자 ID를 연관시키고 그룹 파일을 통해서 그룹 이름과 그룹 ID를 연관시킨다. 

### 추가 그룹 ID

대부분의 UNIX System 버전들은 사용자가 패스워드 파일에서 로그인 이름에 대해 지정된 그룹 ID외에도 추가적인 그룹들에 속할 수 있게 한다. </br>
시스템은 사용자가 로그인할 때 /etc/group 파일을 읽고 해당 사용자가 속한 처으 16개의 항목들을 찾아서 이러한 추가 그룹 ID들을 얻는다. </br>
POSIX 표준을 만족하는 시스템은 프로세스 당 적어도 여덟개의 추가 그룹들을 지원해야 하지만 대부분의 시스템들은 적어도 16개를 지원한다. 

## 신호

신호는 어떠한 조건이 발생했음을 프로세스에게 알려주는 매커니즘이다. </br>
신호를 받은 프로세스가 할 수 있는 일은 세가지이다. </br>
1. 신호를 그냥 무시한다. 0으로 나누기나 프로세스 주소 공간 외부의 메모리 참조 같은 하드웨어에 해당하는 신호의 경우에는 무시하는 것이 바람직하지 않다. 그런 신호를 무시하는 것의 결과는 정의되지 않기 때문이다. </br>
2. 기본 작용이 일어나게 한다. 0으로 나누기 조건의 기본 작용은 프로세스의 종료이다. </br>
3. 신호 발생시 호출될 함수를 제공함. 독자적인 함수를 제공함으로써 우리는 신호가 언제 발생했는지 알 수 있으며 신호를 원하는 방식으로 처리할 수 있게 된다.

신호를 발생하는 조건들은 여러가지다.
예) 가로채키 키(delete, ctrl+c) </br>
중지 키(ctrl+\) </br>
kill 함수를 호출해서 신호를 발생시키는 것 -> 이 함수를 이용하면 한 프로세스에서 다른 프로세스에게 신호를 보낼 수 있지만, 신호를 보내는 프로세스의 사용자가 신호를 받는 프로세스의 소유자이거나 슈퍼 사용자이어야 한다. 

## 시간 값

1. 달력 시간(calander time) -> UTC 기준 1970년 1월 1일 00:00:00 기준으로 삼고 그로부터 흐른 초들의 개수를 센 것이다. </br>
이 시간 값은 파일의 최종 수정 일시를 기록하는 데 쓰인다. 이러한 시간 값들을 담는 기본 시스템 자료 형식은 time_t이다.

2. 프로세스 시간(process time) -> CPU 시간이라도 하는데, 프로세스가 중앙처리장치 자원들을 사용한 시간을 측정한 값. </br>
프로세스 시간의 측정 단위는 클록 틱 수로, 이러한 시간 값들을 담는 기본 시스템 자료 형식은 clock_t이다.

프로세스의 수행 시간을 측정해보면 UNIX System이 한 프로세스에 대해 세 가지 시간 값들을 관리함을 알 수 있다. </br>
* 클록 시간(clock time) -> 벽시계 시간이라고도 한다. 프로세스가 실행된 시간으로, 이 값은 시스템에서 실행되는 다른 프로세스의 개수에도 영향을 받는다. </br>
* 사용자 CPU 시간 -> 사용자 수준 명령들의 수행에 소비된 CPU 시간. 
* 시스템 CPU 시간 -> 프로세스의 요청에 의해 커널이 소비한 CPU 시간.

## 시스템 호출과 라이브러리 함수

UNIX System의 모든 구현은 커널로 직접 이어지는 잘 정의된, 제한된 개수의 진입점들을 제공하는데, 그런 진입점들을 시스템 호출이라고 부른다. </br>
UNIX 시스템들이 채용한 방식은 각 시스템 호출마다 같은 이름의 함수를 표준 C 라이브러리에 두는 것이다. 사용자 프로세스는 표준 C 호출 시퀀스를 통해서 그러한 함수를 호출한다. 그러면 함수는 적절한 커널 서비스를 실행한다. </br>
UNIX 시스템에 대한 대부분의 프로그래머들이 사용하는 인터페이스를 정의하려면 시스템 호출들 뿐만 아니라 일부 라이브러리 함수들도 서술해야 한다. </br>
