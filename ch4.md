# chapter 4 파일과 디렉터리

## 4.2 stat, fstat, fstatat, lstat 함수
int fstat(int fd, struct stat *buf); </br>
int lstat(const char *restrict pathname, struct stat *restrict buf); </br>
int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag); </br>

stat 함수는 pathname 인수로 지정된 파일에 대한 정보를 한 구조체에 담아 돌려준다. </br>
fstat 함수는 fd 인수로 지정된 파일 서술자에 대해 이미 열려 있는 파일에 관한 정보를 돌려준다. </br>
lstat 함수는 stat과 비슷하되 기호 링크에 대한 정보를 돌려준다. </br>
기호 링크가 가리키는 파일이 아니라 기호 링크 자체에 대한 정보임을 주의해야 한다. 

fstat 함수는 fd 인수로 지정된 파일 서술자에 해당하는 열린 디렉터리를 기준으로 한 상대 경로이름에 관한 파일 통계치를 돌려준다. flag 인수는 기호 링크를 따라갈 것인지의 여부를 결정한다. </br>
이 인수로 AT_SYMLINK_NOFOLLOW 플래그를 설정하면 fstatat은 기호 링크를 따라가지 않고 대신 링크 자체에 대한 정보를 돌려준다. </br>

struct stat { </br>
mode_t           st_mode;   /* 파일 종류 및 모드(권한) */ </br>
ino_t            st_ino;    /* i-노드 번호(일련 번호) */ </br>
dev_t            st_dev;    /* 장치 번호(파일 시스템) */ </br>
dev_t            st_rdev;   /* 특수 파일들을 위한 장치 번호 */ </br>
nlink_t          st_nlink;  /* 링크 개수 */ </br>
uid_t            st_uid;    /* 파일 소유자의 사용자 ID */ </br>
gid_t            st_gid;    /* 파일 소유자의 그룹 ID */ </br>
off_t            st_size;   /* 바이트 단위 크기(정규 파일의 경우) */ </br>
struct timespec  st_atim;  /* 마지막 접근 시간 */ </br>
struct timespec  st_mtim;  /* 마지막 수정 시간 */ </br>
struct timespec  st_ctim;  /* 마지막 파일 상태 변경 시간 */ </br>
blksize_t        st_blksize;    /* 최선의 입출력 블록 크기 */ </br>
blkcnt_t         st_blocks    /* 할당된 디스크 블록 개수 */ </br>
}; </br>

timespec 구조체 형식은 초 및 나노초 단위의 시간을 정의한다. </br>
time_t  tv_sec; </br>
long    tv_nsec; </br>

## 4.3 파일 종류
한 UNIX 시스템의 파일들은 대부분 정규 파일 아니면 디렉터리이나, 그 둘에 해당하지 않는 파일들도 있다. </br>
1. 정규 파일(regular file). 가장 흔한 파일로, 어떤 형태이든 자료를 담는다. UNIX 커널은 텍스트 자료와 이진 자료를 구분하지 않는다. 정규 파일의 내용을 어떻게 해석하는지는 그 파일을 처리하는 응용 프로그램의 몫이다. </br>
(프로그램을 실행하려면 반드시 실행 파일의 형식을 알아야 한다. 모든 이진 실행 파일은 커널이 프로그램의 텍스트와 자료를 어디에 적재해야 하는지 알 수 있게 하는 특정한 형식을 따른다. </br>
2. 디렉터리 파일(directory file). 다른 파일들의 이름과 그 파일들에 대한 정보로의 포인터들을 담은 파일이다. 디렉터리 파일에 대한 읽기 권한을 거잔 모든 프로세스는 그 디렉터리의 내용물도 읽을 수 있으나, 디렉터리 파일에 직접 쓸 수 있는 것은 커널뿐이다. </br>
프로세스가 디렉터리를 변경하기 위해서는 파일과 디렉터리 함수들을 사용해야 한다. </br>
3. 블록 특수 파일(block special file). 디스크 드라이브 같은 장치에 대해 고정 크기 단위의 버퍼링 있는 입출력 접근을 제공하는 파일이다. </br>
4. 문자 특수 파일(character special file). 장치에 대한 가변 크기 단위의 버퍼링 없는 입출력 접근을 제공하는 파일이다. 한 시스템의 모든 장치는 블록 특수 파일 아니면 문자 특수 파일이다. </br>
5. FIFO. 프로세스들 사이의 통신에 쓰이는 파일이다. 명명된 파이프라고 부르기도 한다. </br>
6. 소켓. 프로세스들 사이의 비 네트워크 통신에 쓰이는 파일이다. 하나의 호스트 안에 있는 프로세스들 사이의 비 네트워크 통신에 소켓을 사용할 수도 있다. </br>
7. 기호 링크. 다른 파일을 가리키는 파일이다. </br>
파일의 종류는 stat 구조체의 st_mode 멤버에 부호화된다.

POSIX.1은 구현이 메시지 대기열이나 세마포 같은 프로세스 간 통신(IPC) 객체들을 파일로서 나타내는 것을 허용한다. 

<sys/stat.h>의 파일 종류 식별 매크로들 </br>
S_ISREG()    정규 파일 </br>
S_ISDIR()    디렉터리 파일 </br>
S_ISCHR()    문자 특수 파일 </br>
S_ISBLK()    블록 특수 파일 </br>
S_ISFIFO()   파이프 또는 FIFO </br>
S_ISLNK()    기호 링크 </br>
S_ISSOCK()   소켓 </br>

stat 구조체를 이용해서 IPC 객체의 종류를 파악하는 데 쓰이는 매크로들 </br>
S_TYPEISMQ()  메시지 대기열
S_TYPEISSEM()  세마포
S_TYPEISSHM()  공유 메모리 객체

stat 함수를 쓰지 않고 lstat 함수를 사용하는 것은 기호 링크들을 검출하기 위한 것이다. 만일 stat 함수를 사용한다면 기호 링크를 알아보지 못한다. 

## 4.4 사용자-ID-설정(SUID) 비트와 그룹-ID-설정(SGUID) 비트
모든 프로세스에는 각각 여섯 개 이상의 ID들이 연관된다. 

실제(real) 사용자 ID, 실제 그룹 ID : 사용자나 그룹이 실제로 누구인지 알려주는 ID들 </br>
유효(effective) 사용자 ID, 유효 그룹 ID, 추가 그룹 ID들 : 파일 접근 권한 점검에 쓰임. </br>
저장된 사용자 ID, 저장된 그룹 ID : exec류 함수들이 저장함. </br>

실제 사용자 ID와 실제 그룹 ID는 해당 사용자나 그룹이 실제로 누구인지를 알려준다. 이 ID들은 로그인 시 패스워드 파일의 해당 사용자 항목의 두 필드에서 가져온다. </br>
일반적으로 한 로그인 세션 도중에는 이 값들이 변하지 않는다. 그러나 슈퍼사용자 프로세스가 이들을 변경하는 수단이 존재한다. </br>
유효 사용자 ID와 유효 그룹 ID, 그리고 추가 그룹 ID는 파일 접근 권한을 결정한다. </br>
저장된 사용자 ID와 저장된 그룹 ID는 프로그램이 실행될 때 저장해 둔 유효 사용자 ID와 유효 그룹 ID의 복사본을 담고 있다. </br>
프로그램 파일을 실행할 때 일반적으로 프로세스의 유효 사용자 ID는 실제 사용자 ID이고 유효 그룹 ID는 실제 그룹 ID이다. 그러나 파일의 모드 워드(st_mode)에 특별한 플래그를 설정하면 그 파일이 실행될 때 프로세스의 유효 사용자 ID가 파일의 소유자(st_uid)로 설정되게 할 수 있다. 마찬가지로, 파일의 모드 워드의 특정 플래그를 설정하면 파일 실행 시 유효 그룹 ID가 파일의 그룹 소유자(st_gid)로 설정되게 할 수 있다. 파일 모드 워드의 이 두 비트를 각각 사용자-ID-설정(set-user-ID, SUID) 비트와 그룹-ID-설정(set-group-ID, SGID) 비트라고 부른다. </br>
사용자-ID-설정 비트와 그룹-ID-설정 비트는 파일의 st_mode 값에 들어 있다. 이 두 비트를 판정할 때에는 상수 S_ISUID나 S_ISGID를 사용한다. </br>

## 4.5 파일 접근 권한 
st_mode 값에는 파일에 대한 접근 권한 비트들도 부호화되어 있다. 여기서 파일에는 앞에서 말한 모든 종류의 파일이 포함된다. </br>
접근 권한 설정이 정규 파일에만 있는 것이 아니라 디렉터리나 문자 특수 파일 등 모든 종류의 파일에 접근 권한이 있다. 

S_IRUSR : 사용자 읽기 </br>
S_IWUSR : 사용자 쓰기 </br>
S_IXUSR : 사용자 실행 </br>
S_IRGRP : 그룹 읽기 </br>
S_IWGRP : 그룹 쓰기 </br>
S_IXGRP : 그룹 실행 </br>
S_IROTH : 기타 읽기 </br>
S_IWOTH : 기타 쓰기 </br>
S_IXOTH : 기타 실행 </br>

사용자는 파일의 소유자를 뜻한다. 위의 아홉 권한 비트를 수정할 때 chmod 명령을 사용하는데, 이 명령으로 파일 접근 권한을 수정할 때 사용자(소유자)는 u자로, 그룹은 g자로, 기타는 o자로 지정한다. chmod 명령과 일관되게 사용자, 그룹 기타를 사용함. </br>

첫번째 규칙은 파일 접근 권한들을 읽기, 쓰기, 실행 세 범주로 나눌 수 있고 여러 함수들에서 다양한 방식으로 사용된다. </br>
그 어떤 종류의 파일이든 이름으로 파일을 열 때에는 반드시 그 이름에 언급된 각 디렉터리에 대한 실행 권한이 필요하다. 디렉터리에 대한 실행 허용 비트를 검색 허용 비트라고 부르기도 한다. </br>
읽기 권한은 디렉터리를 읽을 수 있는 즉, 디렉터리 안에 담긴 모든 파일이름의 목록을 얻을 수 있는 권한이다. 반면 실행 권한은 접근하고자 하는 경로이름의 한 구성요소로서의 디렉터리를 훑을 수 있는 권한이다. </br>
파일에 대한 읽기 권한은 기존 파일을 읽기를 위해 열 수 있는지의 여부를 결정한다. 이는 open 함수에 O_RDONLY 플래그나 O_RDWR 플래그를 지정할 때에 영향을 미친다. </br>
파일에 대한 쓰기 권한은 기존 파일을 쓰기를 위해 열 수 있는지의 여부를 결정한다. 이는 open 함수에 O_WRONLY 플래그나 O_RDWR 플래그를 지정할 때에 영향을 미친다. </br>
open 함수에 O_TRUNC 플래그를 지정하기 위해서는 해당 파일에 대한 쓰기 권한이 반드시 필요하다. </br>
디렉터리에 대한 쓰기 권한과 실행 권한이 없으면 그 디렉터리에 새 파일을 만들 수 없다. </br>
어떤 파일을 여러 exec류 함수들 중 하나로 실행하려면 그 파일에 대한 실행 권한이 필요하다. 또한 파일이 반드시 정규 파일이어야 한다. </br>

## 4.6 새 파일과 디렉터리의 소유권
새 파일의 사용자 ID는 프로세스의 유효 사용자 ID로 설정된다. 그룹 ID의 설정 방식은 상황에 따라 다르다. </br>
1. 프로세스의 유효 그룹 ID를 새 파일의 그룹 ID로 사용한다.
2. 파일이 생성된 디렉터리의 그룹 ID를 새 파일의 그룹 ID로 사용한다.

둘째 방식, 즉, 디렉터리의 그룹 ID를 물려받는 방식에서는 항상 한 디렉터리 안에 생성된 모든 파일과 디렉터리가 동일한 그룹 ID를 가지게 된다. </br>

## 4.7 access 함수와 faccessat 함수
파일을 열 때 커널은 유효 사용자 ID와 유효 그룹 ID에 근거해서 접근 허용 판정을 수행한다. 그런데 접근 허용 판정이 실제 사용자 ID와 실제 그룹 ID에 근거해서 수행되길 프로세스가 원할 수도 있다. </br>
프로세스가 사용자-ID-설정 기능이나 그룹-ID-설정 기능을 통해서 다른 누군가의 신원으로 실행될 때 그런 방식이 유용하다. access 함수와 faccessat 함수는 실제 사용자 ID와 실제 그룹 ID에 근거해서 그러한 판정을 수행해 준다. </br>

#include <unistd.h> </br>
int access(const char *pathname, int mode); </br>
int faccessat(int fd, const char *pathname, int mode, int flag); </br>
mode에는 파일의 존재 여부를 알고 싶으면 F_OK를 지정하고, 그외에는 아래와 같이 지정하면 된다. </br>
R_OK : 읽기 권한 판정 </br>
W_OK : 쓰기 권한 판정 </br>
X_OK : 실행 권한 판정 </br>

faccessat 함수는 pathname 인수가 절대 경로이름이거나 fd 인수의 값이 AT_FDCWD이고 pathname 인수가 상대 경로이면 access와 동일하게 작동한다. 그렇지 않은 경우 faccessat은 pathname을 fd인수가 가리키는 열린 디렉터리를 기준으로 평가한다. </br>
flag 인수로는 faccessat의 작동 방식을 변경할 수 있다. 만일 이 인수에 AT_EACCESS 플래그를 설정하면 접근 권한 판정이 함수를 호출한 프로세스의 유효 사용자 ID와 유효 그룹 ID에 근거해서 수행된다. </br>

## 4.8 umask 함수
umask 함수는 현재 프로세스에 대한 파일 모드 생성 마스크를 설정하고 마스크의 이전 값을 돌려준다. </br>
#include <sys/stat.h> </br>
mode_t umask(mode_t cmask); </br>
cmask 인수에는 아홉 상수들 중 임의의 것들을 비트별 논리합(OR)으로 결합한 값을 지정한다. </br>
파일 모드 생성 마스크는 프로세스가 새 파일이나 새 디렉터리를 생성할 때 항상 적용된다. 파일 모드 생성 마스크에 켜져 있는 비트들은 파일 생성 시 mode 인수의 해당 비트들을 끄는 역할을 한다. </br>

대부분의 유닉스 시스템에서 로그인 시 셸의 시동 파일에 의해 umask가 한번 설정된 후 변하지 않는다. 하지만 새 파일을 생성하는 프로그램을 작성할 때 특정 접근 권한 비트들이 반드시 활성화되게 하고 싶다면 반드시 프로세스가 실행되는 도중에 umask 값을 변경해야 한다. </br>
모든 셸에는 현재 파일 모드 생성 마스크를 설정하거나 출력하는 데 사용할 수 있는 내장 umask 명령이 있다. </br>
0400 : 사용자 읽기 </br>
0200 : 사용자 쓰기 </br>
0100 : 사용자 실행 </br>
0040 : 그룹 읽기 </br>
0020 : 그룹 쓰기 </br>
0010 : 그룹 실행 </br>
0004 : 기타 읽기 </br>
0002 : 기타 쓰기 </br>
0001 : 기타 실행 </br>
단일 UNIX 규격은 umask 명령이 기호 모드로도 작동해야 한다고 요구한다. 8진수와 달리 기호 형식은 거부할 권한들이 아니라 허용할 권한들에 해당한다. </br>

## 4.9 chmod, fchmod, fchmodat 함수
