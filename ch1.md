# 1. UNIX 시스템의 개요

## 1.2 UNIX 기반구조
운영체제는 컴퓨터의 하드웨어 자원들을 제어하는, 그리고 프로그램이 실행될 수 있는 환경을 제공하는 소프트웨어라고 정의할 수 있다. </br>
이것을 커널(kernel)이라고 부르는데, 이는 커널이 비교적 크기가 작으며 실행 환경의 핵심부에 놓여 있기 때문이다. 

커널에 대한 인터페이스는 시스템 호출이라고 부르는 소프트웨어 계층이다. 공통 함수 라이브러리들은 이러한 시스템 호출 인터페이스를 기반으로 삼아 구축된다. </br>
응용 프로그램이 시스템 호출들을 사용하는 것도 가능하다. 셸은 다른 프로그램의 실행을 위한 인터페이스를 제공하는 특별한 응용 프로그램이다. </br>
넓은 의미의 운영체제에는 커널뿐만 아니라 컴퓨터를 유용하게 하며 컴퓨터에 개성을 부여하는 다른 모든 소프트웨어도 포함된다. </br>
'다른 모든 소프트웨어'로는 시스템 유틸리티, 응용 프로그램, 셸, 공통 함수 라이브러리 등이 있다.

## 1.3 로그인

### 로그인 이름
유닉스 시스템에 로그인할 때에는 로그인 이름을 입력한 후 패스워드를 입력한다. </br>
시스템은 입력된 로그인 이름을 자신의 패스워드 파일에서 찾아보는데, 그 패스워드 파일은 보통 /etc/password이다. </br>
패스워드 파일을 실제로 보면 하나의 행이 콜론(:)으로 구분된 필드 일곱개로 구성되어 있다. </br>
일곱 필드는 순서대로 로그인 이름, 암호화된 패스워드, 사용자 ID를 뜻하는 정수(205), 그룹 ID를 뜻하는 정수, 주석 필드, 홈 디렉터리(/home/sar), 셸 프로그램(/bin/ksh)이다.

sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh

### 셸
로그인이 성공하면 일반적으로 약간의 시스템 정보가 화면에 나타나고 셸 프로그램에 명령을 입력할 수 있게 된다. </br>
셸은 사용자 입력을 읽어서 명령을 실행하는 명령줄 해석기이다. 셸에 대한 사용자 입력은 보통 터미널을 통해서 주어지지만, 파일(셸 스크립트)에서 주어지는 경우도 있다. </br>
시스템은 패스워드 파일의 현재 사용자에 대한 행의 마지막 필드에 근거해서 혀재 사용자를 위해 실행할 셸을 결정한다. 

## 1.4 파일과 디렉터리

### 파일 시스템
UNIX의 파일 시스템은 디렉터리들과 파일들을 계통적으로 조직화한 것이다. 파일 시스템의 모든 것은 루트(root)라고 부르는 디렉터리에서 시작한다. 루트 디렉터리의 이름은 한 문자짜리 /이다. </br>
디렉터리는 디렉터리 항목들을 담은 파일이다. 논리적으로 하나의 디렉터리 항목은 파일 이름과 함께 파일의 특성들을 서술하는 정보 구조체를 담고 있는 어떤 것이라고 생각하면 된다. </br>
파일의 특성들로는 파일의 종류, 파일의 크기, 파일의 소유자, 파일에 대한 접근 권한, 파일이 마지막으로 수정된 일시 등이 있다. </br>
stat 함수와 fstat 함수는 한 파일의 모든 특성을 담은 정보 구조체를 돌려준다. 

### 파일 이름
한 디렉터리 안의 이름을 파일이름이라고 부른다. 파일이름에 사용할 수 없는 문자는 단 두개로, 바로 슬래시 문자(/)와 널 문자이다. </br>
슬래시는 하나의 경로 이름을 구성하는 파일이름들을 구분하는 역할을 하고, 널 문자는 하나의 경로이름의 끝을 표시한다. </br>
파일이름에는 보통의 인쇄 가능한 문자들만 사용하는 것이 바람직하다. POSIX.1은 파일이름에 사용할 수 있는 문자를 영문자(a-z, A-Z), 숫자(0-9), 마침표(.), 대시(-), 밑줄(_)로만 제한한다. </br>
새 디렉터리를 만들면 자동으로 생성되는 파일이름 두개가 있는데, 도트(.)와 도트-도트(..)이다. 현재 디렉터리는 ., 부모 디렉토리는 ..이다. 루트 디렉터리에서는 도트-도트가 도트와 같다.

### 경로 이름
하나 이상의 파일이름들이 슬래시로 연결된 형태이다. 경로이름의 첫 글자가 슬래시일 수도 있다. 슬래시로 시작하는 경로이름을 절대 경로이름이라고 부르고 그렇지 않은 경로이름을 상대 경로이름이라고 부른다. </br>
상대 경로이름은 현재 디렉터리에 상대적인 파일을 지칭한다. 한 파일 시스템의 루트 디렉터리를 뜻하는 이름(/)은 파일이름이 전혀 없다는 점에서 특별한 경우에 해당하는 절대 경로이름이다.

### 작업 디렉터리
모든 프로세스에는 작업 디렉터리가 있는데, 이를 현재 작업 디렉터리라고 부른다. </br>
작업 디렉터리는 모든 상대 경로이름이 해석되는 기준으로 쓰이고, 프로세스는 chdir 함수를 이용해서 자신의 작업 디렉터리를 변경할 수 있다.

### 홈 디렉터리
사용자가 로그인 하면 작업 디렉터리는 사용자의 홈 디렉터리로 설정된다. 홈 디렉터리의 구체적인 경로 이름은 패스워드 파일 중 현재 사용자의 항목에 들어있다.

## 1.5 입력과 출력

### 파일 서술자
파일 서술자는 커널이 한 프로세스가 접근하는 파일들을 식별하기 위해 사용하는 것으로 음이 아닌 작은 정수 값이다. </br>
프로세스가 기존 파일을 열거나 새 파일을 생성하면 커널은 그 파일을 읽거나 쓸 때 사용할 파일 서술자를 돌려준다.

### 표준 입력, 표준 출력, 표준 오류
관례상 모든 셸은 프로그램이 새로 실행될 때마다 세개의 파일 서술자를 연다. 바로 표준 입력, 표준 출력, 표준 오류이다.

### 버퍼링 없는 입출력
open, read, write, lseek, close 함수는 버퍼링 없는 입출력 기능을 제공한다. 이 함수들은 모두 파일 서술자에 대해 작동한다.

### 표준 입출력
표준 입출력 함수들은 버퍼링 없는 입출력 함수들에 대한 버퍼링 있는 인터페이스를 제공한다. 이것들을 이용하면 프로그래머가 최적의 버퍼 크기를 선택해야 하는 부담이 사라진다. </br>
또, 입력을 줄 단위로 처리하는 작업이 간단해진다. </br>
fgets 함수는 하나의 줄 전체를 읽어 들인다. read 함수는 바이트들을 지정된 개수만큼만 읽어 들인다. 가장 많이 사용하는 표준 입출력 함수는 printf이다. printf를 호출하는 프로그램에서는 항상 <stdio.h> 헤더를 포함시키는데 표준 입출력 함수의 원형이 포함되어 있기 때문이다.

## 1.6 프로그램과 프로세스

### 프로그램
프로그램은 디스크의 디렉터리에 있는 실행 파일이다. 프로그램의 실행은 일곱 가지 exec 함수 중 하나의 호출에 의해 시작딘다. 그러면 커널은 디스크의 프로그램을 메모리로 읽어 들여서 실행한다. 

### 프로세스와 프로세스 ID
현재 실행되고 있는 프로그램의 한 인스턴스를 프로세스라고 부른다. 실행 중인 프로그램을 태스크(task, 과제)라고 부르는 운영체제도 있다. </br>
UNIX 시스템은 모든 프로세스에 각자 고유한 수치 식별자가 있음을 보장한다. 그런 식별자를 프로세스 ID라고 부른다. 프로세스 ID는 항상 음이 아닌 정수이다.

#### 도해 1.6 hello.c
프로그램이 실행되면 프로그램은 getpid 함수를 호출해서 자신의 프로세스 ID를 얻는다. getpid는 pid_t 형식의 값을 돌려준다. 이 값의 크기는 크기가 긴 정수(long integer)에 맞는 크기임을 표준이 보장한다. </br>
printf를 호출할 때에는 출력할 인수들 각각의 크기를 지정해야 하므로 이 값이 가질 수 있는 가장 큰 크기에 해당하는 형식으로 캐스팅해야 한다. 대부분의 프로세스 ID는 int 하나에 맞는 크기이지만, 이식성을 위해서는 long을 사용하는 것이 좋다.

### 프로세스 제어
fork, exec, waitpid가 프로세스 제어를 위해 사용하는 함수들이다.

#### 도해 1.7 shell1.c
프로그램은 표준 입출력 함수 fgets를 이용해서 표준 입력을 한번에 한줄씩 읽어들인다. 한줄의 첫 문자가 파일 끝 문자이면 fgets는 널 포인터를 돌려준다. 그러면 루프가 끝나고 프로세스가 종료된다. </br>
fgets가 돌려준 각 줄은 새 줄 문자와 널 바이트 하나로 끝나므로 표준 C 함수 strlen으로 한 줄의 길이를 구한다. 길이를 구한 다음에는 새 줄 문자를 널 바이트로 대체한다. execlp 함수가 새 줄로 끝나는 문자열이 아니라 널로 끝나는 문자열을 인수로 받기 때문이다. </br>
다음으로는 fork를 호출해서 새 프로세스를 생성한다. 이 프로세스는 그 함수를 호출한 프로세스의 복사본이다. fork는 부모 프로세스에게는 새로 생성된 자식 프로세스의 프로세스 ID를 돌려주고, 자식 프로세스에게는 0을 돌려준다. </br>
자식 프로세스에서는 execlp를 호출해서 표준 입력에서 읽은 명령을 실행한다. 이에 의해 자식 프로세스가 새 프로그램 파일로 대체된다. </br>
자식 프로세스는 execlp를 이용해서 새 프로그램 파일을 실행하므로, 부모 프로세스는 자식이 종료될 때까지 기다려야 한다. 이를 위해 부모는 waitpid를 호출하는데, 이때 자신이 기다릴 프로세스 ID를 지정한다. </br>
이 프로그램의 한계는, 실행하고자 하는 명령에 인수들을 넘겨주지 못한다는 것이다. 인수들을 넘겨줄 수 있으려면 입력 줄을 해석해서 적절한 관례에 따라 인수들을 분리하고 그런 다음 각 인수를 execlp 함수의 개별 매개변수로서 넘겨주어야 한다. 하지만 UNIX 시스템의 프로세스 제어 함수들의 작동 방식을 잘 보여준다는 점에서 여전히 유용한 프로그램이다. 

### 스레드와 스레드 ID
일반적으로 하나의 프로세스에는 제어의 줄기가 하나만 존재한다. 그러나 문제의 서로 다른 부분을 여러 개의 제어 줄기로 처리할 때 더 풀기 쉬워지는 문제들도 있다. </br>
또한 제어의 줄기가 여러 개이면 다중 프로세서 시스템에서 가능한 병렬성을 활용할 수 있게 된다. 그러한 제어의 줄기를 스레드(thread)라고 한다. </br>
한 프로세스의 모든 스레드는 동일한 주소 공간과 파일 서술자들, 스택들, 프로세스 관련 특성들을 공유한다. </br>
각 스레드는 자신만의 스택에서 실행되나, 모든 스레드는 자신과 같은 프로세스에 속한 다른 스레드의 스택에 접근할 수 있다. 스레드들이 같은 메모리에 접근할 수 있기 때문에, 일관성이 깨지지 않게 하려면 공유 자료에 대한 여러 스레드들의 접근을 동기화할 필요가 있다. </br>
프로세스처럼 스레드도 ID를 식별하지만, 스레드 ID들은 한 프로세스 안에서만 유효하다. 스레드 ID는 프로세스 안에서 스레드들을 다룰 때 특정 스레드를 지칭하는 용도로 쓰인다. </br>
스레드를 제어하는 함수들은 프로세스를 제어하는 함수들과 비슷하지만 프로세스 모형이 확립되고 UNIX 시스템에 추가된 것이기 때문에 스레드 모형과 프로세스 모형에는 다소 까다로운 상호작용이 존재한다.

## 1.7 오류 처리
UNIX 시스템 함수들은 오류가 발생하면 음의 값을 돌려준다. 또한 오류의 원인을 말해 주는 값이 errno라는 정수 개체에 설정되는 경우도 많다. 오류 시 음의 값을 돌려주는 것과는 다른 관례를 사용하는 함수도 있다. </br>
헤더 파일 <errno.h>에는 기호 errno와 errno에 설정될 수 있는 각 값에 대한 상수들이 정의되어 있다.
POSIX와 ISO C는 errno를 정수 형식의 수정 가능한 왼쪽값(lvalue)으로 확정되는 하나의 기호로 정의된다. 그러한 왼쪽값의 구체적인 형태는오류 번호를 담은 정수일 수도 있고 오류 번호를 가리키는 포인터를 돌려주는 함수일 수도 있다. </br>
extern int errno; </br>
다중 스레드를 지원하는 환경에서는 프로세스 주소 공간을 여러 스레드가 공유하며, 따라서 스레드 사이에서 오류 번호가 혼선되지 않으려면 각 스레드마다 개별적인 errno의 복사본을 둘 필요가 있다. </br>
extern int *__errno_location(void); </br>
#define errno (*__errno_location()) </br>
errno에 대해서 알아둬야 할 것은 첫째로, 어떤 루틴에서 오류가 없었다고 해서 errno의 값이 비워지지는 않는다. 따라서 errno의 값은 함수의 반환값을 통해서 오류가 발생했음을 확인한 경우에만 점검해야 한다. </br>
둘째로, errno의 값을 0으로 설정하는 함수는 없으며, <errno.h>에 정의된 상수들 중 값이 0인 것은 없다. </br>
#include <string.h> </br>
char *strerror(int errnum); /* 오류 메시지의 출력을 도움 */ </br>
이 함수는 주어진 errnum에 해당하는 오류 메시지 문자열을 가리키는 포인터를 돌려준다. errnum 인수에는 errno 값을 지정한다. </br>
#include <stdio.h> </br>
void perror(const char *msg); </br>
이 함수는 먼저 msg가 가리키는 문자열을 출력하고, 그런 다음 콜론(:) 하나와 빈칸, 그리고 errno 값에 해당하는 오류 메시지를 출력하고, 마지막으로 새 줄을 출력한다.

#### 도해 1.8 testerror.c
perror의 인수로 argv[0], 즉 프로그램 이름을 넘겨준다는 점을 주목해야 한다. 이러면 프로그램을 다음처럼 파이프라인의 일부로 실행해도, 출력된 오류 메시지가 세 프로그램 중 어떤 것에서 비롯되었는지 알 수 있다.

### 오류 복구
<errno.h>에 정의된 오류들은 두가지로 분류된다. 첫째로, 치명적 오류이고 둘째는 치명적이지 않은 오류이다. </br>
치명적 오류에는 복구 동작이 전혀 없다. 할 수 있는 일은 그저 오류 메시지를 사용자 화면이나 로그 파일에 출력하고 프로그램을 종료하는 것 뿐이다. </br>
치명적이지 않은 오류는 좀 더 안정적으로 처리하는 것이 가능한 경우가 많다. 대부분의 치명적이지 않은 오류는 임시적(자원 부족 등)이며, 시스템 활동이 적을 때에는 발생하지 않을 수도 있다. </br>
자원 관련 치명적이지 않은 오류에는 EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, EWOULDBLOCK이 포함되며 경우에 따라 ENOMEM도 포함된다. </br>
EBUSY는 공유 자원이 사용 중임을 가리키는 경우 치명적이지 않은 오류로 간주할 수 있다. EINTR는 느린 시스템 호출을 가로채는 경우 치명적이지 않은 오류로 간주할 수 있다. </br>

자원 관련 비치명적 오류에 대한 전형적인 복구 동작은 잠시 지연했다가 다시 시도하는 것이다. 시도를 반복할 때마다 점점 더 긴 시간을 기다리는 지수적 후퇴(exponential backoff) 알고리즘을 사용하는 응용 프로그램도 있다.

## 1.8 사용자 식별

### 사용자 ID
패스워드 파일에 있는 사용자 ID 필드는 시스템이 사용자를 식별하는 데 사용하는 수치값이다. 이 사용자 ID는 시스템 관리자가 사용자의 로그인 이름을 지정할 때 함께 배정하며, 사용자 자신이 바꿀 수 없다. </br>
사용자 ID가 0인 사용자를 루트 또는 슈퍼사용자(super user)라고 부른다. 슈퍼사용자에 대한 패스워드 파일의 행에서 로그인 이름은 보통 root이며, 이 사용자의 특별한 권한을 슈퍼사용자 특권이라고 부른다.

### 그룹 ID
그룹 ID는 시스템 관리자가 사용자의 로그인 이름을 배정할 때 함께 배정하는 수치이다. 일반적으로 패스워드 파일에는 그룹ID와 같은 사용자 항목들이 여러 개 존재한다. </br>
보통의 경우 그룹은 사용자들을 프로젝트나 부서 별로 조직화하는 용도로 쓰인다. 이를 통해서 파일 같은 자원들을 같은 그룹의 구성원들이 공유할 수 있게 된다. </br>
그룹 이름(문자열)을 그룹 ID(수치)에 대응시키는 그룹 파일도 있다. 보통의 경우 /etc/group 파일이 그런 용도로 쓰인다. </br>
파일 시스템은 디스크의 각 파일마다 그 파일을 소유한 사용자의 사용자 ID와 그룹 ID를 함께 저장한다. </br>
사용자에게는 수치보다 문자열 이름이 더 다루기 쉽기 때문에, 패스워드 파일은 사용자 ID와 함께 그에 해당하는 로그인 이름을 저장하며, 그룹 파일 역시 그룹 ID와 함께 그에 해당하는 그룹 이름을 저장한다.

### 추가 그룹 ID
UNIX 시스템들은 한 사용자가 패스워드 파일에 저장된 로그인 이름에 대한 그룹 ID에 해당하는 그룹 이외의 그룹에도 속할 수 있게 한다. 한 사용자가 최대 16개의 추가 그룹에 속할 수 있게 했다. </br>
시스템은 사용자가 로그인할 때 /etc/group 파일에서 그 사용자가 등록되어 있는 처음 16개의 항목을 읽어서 이러한 추가 그룹 ID를 얻는다.

## 1.9 신호
신호는 어떤 특정한 조건이 발생했음을 프로세스에게 알려주는 기법이다. 프로세스가 그러한 신호에 대해 할 수 있는 일은 다음 세가지 중 하나다. </br>
1) 신호를 무시한다. 2) 기본 동작이 일어나게 한다. 0으로 나누기 조건의 경우 기본 동작은 프로세스의 종료이다. 3) 신호를 처리할 함수가 호출되게 한다. 신호 발생 시 호출될 함수를 미리 지정해 놓으면 원하는 방식으로 처리 가능하다. </br>

## 1.10 시간 값
UNIX 시스템들은 두 종류의 시간 값을 유지했다. 1) 달력 시간. 이 값은 UNIX 기원으로부터 흐른 초의 개수이다. 이 시간 값은 이를테면 파일이 마지막으로 수정된 일시를 기록하는데 쓰인다. </br>
2) 프로세스 시간. CPU 시간이라고도 부르는 이 시간 값은 한 프로세스가 중앙 처리장치 자원들을 사용한 시간을 측정한 것이다. 프로세스 시간의 단위는 클록 틱(clock tick)이다. </br>
UNIX 시스템은 한 프로세스에 대해 클록 시간, 사용자 CPU 시간, 시스템 CPU 시간 총 3개의 값을 관리한다. </br>
클록 시간은 벽시계 시간이라고도 부르는데, 프로세스가 실행된 전체 시간을 뜻하고 구체적인 값은 시스템에서 실행되고 있는 다른 프로세스의 수에 영향을 받는다. </br>
사용자 CPU 시간은 사용자 명령들에 소비된 CPU 시간이다. 사용자 CPU 시간과 시스템 CPU 시간을 합친 것을 CPU 시간이라고 부른다. </br>

## 1.11 시스템 호출과 라이브러리 함수
모든 운영체제는 프로그램이 커널에게 서비스를 요청할 수 있는 서비스 지점들을 제공한다. </br>
UNIX 시스템의 모든 구현은 직접 커널로 들어가는 잘 정의된, 제한된 개수의 진입점을 제공하는데, 이것을 시스템 호출이라고 부른다.
