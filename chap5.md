# chapter 5 표준 I/O 라이브러리

## 5.2 스트림과 FILE 객체

표준 I/O 라이브러리에서 파일을 생성하거나 열면 파일 스트림을 얻게 되는데, 이를 "스트림을 파일에 연결시켰다"고 말한다. </br>
표준 I/O 파일 스트림은 단일 바이트 문자 집합과 사용할 수도 있고 다중 바이트 문자 집합과 사용할 수도 있다. </br>
문자가 단일 바이트로 접근되는지 다중 바이트로 접근 되는지를 결정하는 것은 스트림의 지향이다. 한 스트림이 처음 생성되었을 때에는 스트림에 지향이 없는 상태이다. </br>
지향이 없는 스트림에 대해 다중 바이트 I/O 함수가 호출되면 스트림의 지향은 넓은 문자 지향이 된다. </br>
지향이 없는 스트림에 바이트 I/O 함수가 호출되면 스트림의 지향은 바이트 지향이 된다. </br>
fropen 함수로는 스트림의 지향을 지울 수 있고, fwide 함수로는 스트림의 지향을 설정할 수 있다.
    #include <stdio.h>
    #include <wchar.h>

    int fwide(FILE *fp, int mode);
fwide 함수의 행동은 mode 인수에 주어진 값에 따라 달라진다. </br>
1. mode가 음수이면 fwide는 지정된 스트림을 바이트 지향으로 설정하려고 한다.
2. mode가 양수이면 fwide는 지정된 스트림을 넓은 문자 지향으로 설정하려고 한다.
3. mode가 0이면 fwide는 지향을 설정하지 않고 그냥 스트림의 현재 지향을 뜻하는 값을 돌려준다. </br>
지향이 이미 설정되어 있는 스트림에 대해서는 fwide가 지향을 변경하지 않음을 주의해야 한다. 또한 이 함수가 오류코드를 반환하지 않는다는 것도 중요하다. </br>
표준 I/O 함수 fopen으로 스트림을 열면 fopen은 FILE 객체를 가리키는 포인터를 돌려준다. </br>
FILE은 표준 I/O 라이브러리가 스트림을 관리하는 데 필요한 모든 정보를 담은 하나의 구조체이다. 그러한 정보에는 실제 I/O에 쓰이는 파일 서술자, 스트림을 위한 버퍼를 가리키는 포인터, 그 버퍼의 크기, 버퍼에 현재 들어 있는 문자 개수, 오류 플래그 등이 포함된다. </br>
스트림을 사용할 때에는 그냥 해당 FILE 포인터를 각 표준 I/O 함수의 인수로 지정하면 된다.

## 5.3 표준 I/O 스트림들 - 표준 입력, 표준 출력, 표준 오류

모든 프로세스에는 세 가지의 미리 정의된 스트림들이 자동으로 제공된다. </br>
이 스트림들은 표준 파일 서술자 STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO와 동일한 파일들을 가리킨다. </br>
프로그램 안에서는 이 세 표준 I/O 스트림들을 미리 정의된 파일 포인터 stdin, stdout, stderr로 참조한다. 

## 5.4 버퍼링

표준 I/O 라이브러리가 제공하는 버퍼링의 목표는 read 호출과 write 호출의 횟수를 최소화하는 것이다. </br>
표준 I/O 라이브러리는 각 I/O 스트림에 대해 버퍼링을 자동으로 적용함으로써 프로그래머가 버퍼링에 신경 쓰는 일이 없도록 한다. 

표준 I/O 라이브러리에서 제공하는 버퍼링은 다음과 같다.

1. 전체 버퍼링. 이 경우 실제 I/O는 표준 I/O 버퍼가 꽉 찼을 때에만 일어난다. 보통의 경우 표준 I/O 라이브러리는 디스크에 있는 파일들에 이 전체 버퍼링을 적용한다. </br>
전체 버퍼링에 쓰이는 버퍼는 주어진 한 스트림에 대해 I/O가 처음 수행될 때 표준 I/O 함수가 malloc을 호출해서 할당한다. </br>
표준 I/O 버퍼의 내용을 디스크에 기록하는 작업을 방출이라고 한다. 버퍼는 표준 I/O 루틴이 자동으로 방출할 수도 있고, 프로그램의 fflush 호출에 의해 명시적으로 방출될 수도 있다. </br>
UNIX 환경에서 방출은 표준 I/O 라이브러리의 맥락에서는 버퍼 내용의 기록을 의미하지만, 터미널 드라이버의 맥락에서는 버퍼에 저장되어 있는 자료의 폐기를 의미한다. 
2. 줄 단위 버퍼링. 이 경우 표준 I/O 라이브러리는 입력이나 출력에서 새줄 문자를 만났을 때 I/O를 수행한다. 이 버퍼링 하에서 텍스트를 출력할 때 실제 I/O는 하나의 줄이 완성되었을 때만 일어나므로, 텍스트를 한 번에 한 문자씩만 출력해도 성능이 크게 떨어지지 않는다. </br>
줄 단위 버퍼링은 터미널을 가리키는 스트림에 주로 쓰인다. </br>

줄 단위 버퍼링에서는 다음을 주의해야 한다. </br>
1. 표준 I/O 라이브러리가 각 줄의 버퍼링에 사용하는 버퍼의 크기는 고정되어 있으며, 새줄 문자가 나타나기 전에라도 버퍼가 꽉 차면 실제 I/O가 수행된다.
2. 표준 I/O 라이브러리를 통해서 (a) 버퍼링 되지 않는 스트림이나 (b) 줄 단위 버퍼링 스트림으로부터의 입력이 요청되면, 줄 단위 버퍼링 출력 스트림들이 모두 방출된다.
단, (b)는 자료를 커널이 요청한 경우에만 해당한다. 요청된 자료가 이미 버퍼에 들어 있어서 커널이 자료를 읽을 필요가 없는 경우에는 해당하지 않는다. (a)의 경우, 즉, 버퍼링이 없는 스트림에서는 모든 입력에 대해 커널이 자료를 읽어야 한다.
3. 버퍼링 없음. 이 경우 표준 I/O 라이브러리는 문자들을 버퍼링하지 않는다. 보통의 경우 표준 오류 스트림은 버퍼링되지 않는다. </br>
ISO C는 다음을 요구한다. (1. 표준 입력과 표준 출력은 전체 버퍼링이어야 한다. 2. 표준 오류는 결코 전체 버퍼링이 아니다.)
대부분의 구현들은 다음과 같다. (1. 표준 오류는 항상 버퍼링되지 않는다. 2. 그 외의 스트림들은 터미널 줄을 가리키는 경우에는 줄 단위 버퍼링이고 그렇지 않으면 전체 버퍼링이다.)

기본 버퍼링 방식이 적합하지 않은 스트림이 있다면 다음 두 함수를 사용해 스트림의 버퍼링 방식을 변경할 수 있다.
    #include <stdio.h>

    void setbuf(FILE *restrict fp, char *restrict buf);
    int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
이 함수들은 반드시 스트림을 연 후(두 함수 모두 첫 인수로 유효한 파일 포인터를 받으므로 당연한 일이다), 그러나 스트림에 대해 다른 연산을 수행하기 전에 호출해야 한다. </br>
setbuf로는 버퍼링을 켜거나 끌 수 있다. 버퍼링을 켜려면 길이가 BUFSIZ인 버퍼를 가리키는 포인터를 buf 인수에 지정해야 한다. 그러면 fp가 가리키는 스트림에 대해 전체 버퍼링이 설정되는 것이 보통이나, 스트림이 터미널 장치에 연관되어 있다면 줄 단위 버퍼링을 설정하는 구현도 있다. </br>
버퍼링을 끄려면 buf에 NULL을 넣으면 된다. 

버퍼는 언제라도 방출 가능하다. 
    #include <stdio.h>

    int fflush(FILE *fp);
이 함수는 스트림에 대해 아직 기록되지 않은 자료를 커널에 넘겨준다. 

## 5.5 스트림 열기

        #include <stdio.h>

        FILE *fopen(const char *restrict pathname, const char *restrict type);
        FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
        FILE *fdopen(int filedes, const char *type);
1. fopen 함수는 지정된 파일을 연다. </br>
2. freopen 함수는 지정된 파일을 지정된 스트림으로 연다. 스트림이 이미 열려 있으면 닫은 후 다시 연다. </br>
3. fdopen 함수는 기존 파일 서술자를 받아서 그 서술자에 표준 I/O 스트림을 연관시킨다. </br>

type의 값들에서 문자 b는 표준 I/O 시스템이 파일의 내용을 텍스트가 아니라 이진 값으로 다루도록 지정하는 효과를 낸다. </br>
fdopen의 type 인수는 의미가 좀 다른데, 이 함수는 이미 열려 있는 파일에 대한 서술자를 받으므로 스트림을 쓰기용으로 연다고 해도 파일이 절단되지는 않는다. 또한, 표준 I/O 추가 모드로 파일을 생성하지 못한다. 

읽기 및 쓰기를 위해 파일을 여는 경우, 다음과 같은 제약이 적용된다.
1. 출력 이후 즉시 입력을 수행할 수 없는데, fflush나 fseek, fsetpos, rewind를 거쳐야 한다.
2. 입력 이후 즉시 출력을 수행할 수 없는데, fseek, fsetpos, rewind를 거치거나 입력 연산이 파일의 끝을 만나야 한다.

열린 스트림을 닫을 때에는 fclose 함수를 사용한다. 
        #include <stdio.h>

        int fclose(FILE *fp);
파일이 닫히기 전에 버퍼에 있는 출력 자료가 방출된다. 

## 5.6 스트림 읽고 쓰기

스트림을 연 후에는 스트림에 대해 세 종류의 서식 없는 I/O 연산들을 수행할 수 있다.
1. 문자 단위 I/O. 한번에 한 문자씩 읽거나 쓸 수 있다.
2. 줄 단위 I/O. 한번에 한 줄씩 읽거나 쓰고 싶은 경우에는 fgets 함수나 fputs 함수를 사용한다. 각 줄은 세줄 문자로 끝난다.
3. 직접 I/O. 이런 종류의 연산은 fread 함수와 fwrite 함수가 지원한다. 각 I/O 연산마다 지정된 크기의 여러 객체들을 읽거나 쓴다.

### 입력 함수들

다음 세 함수들은 한번에 하나의 문자를 읽어들인다. 
        #include <stdio.h>

        int getc(FILE *fp);
        int fgetc(FILE *fp);
        int getchar(void);
getchar 함수는 getc(stdin)과 동등하게 정의된다. getc와 fgetc의 차이는 getc가 매크로로 구현될 수 있는 반면, fgetc는 그럴 수 없다.
1. getc의 인수에 side effect를 가지는 표현식을 지정하지는 말아야 한다.
2. fgetc는 반드시 실제의 함수이므로 그 주소를 취할 수 있다. 예를 들어 fgetc의 주소를 다른 함수의 인수로 지정할 수 있다.
3. fgetc 호출은 getc보다 더 많은 시간을 소비할 수 있다.

이 세 함수들은 스트림의 다음 문자를 돌려주는데, 문자 자체는 unsigned char 형식으로 취급되지만, 반환값은 그것을 int로 변환한 결과이다. </br>
문자가 unsigned char 형식인 이유는 최상위 비트가 설정되어 있다고 해도 음수가 되지 않기 때문이다. </br>
이 세 함수들이 오류가 발생했을 때와 파일 끝에 도달했을 때 모두 동일한 값을 돌려줌을 주의할 것. 두 상황을 구분하려면 ferror 함수나 feof 함수를 호출해야 한다.

        #include <stdio.h>

        int ferror(FILE *fp);
        int feof(FILE *fp);
        void clearerr(FILE *fp);
대부분의 구현은 각 스트림의 FILE 객체에 오류 플래그, 파일 끝 플래그를 둔다. </br>
clearerr를 호출하면 두 플래그 모두 해제된다. </br>
스트림에서 문자를 읽은 후 그 문자를 다시 스트림에 되돌려 놓는 것도 가능하다. ungetc 함수가 그런 일을 한다.
        #include <stdio.h>

        int ungetc(int c, FILE *fp);

이 함수로 스트림에 되돌려 넣은 문자는 다음 번 문자 읽기에서 반환된다. 문자들을 여러 번 읽고 여러 번 되돌려 넣은 경우, 문자들은 되돌려 넣은 순서의 역순으로 다시 읽힌다. </br>

### 출력 함수
        #include <stdio.h>

        int putc(int c, FILE *fp);
        int fputc(int c, FILE *fp);
        int putchar(int c);
입력 함수들처럼, putchar는 putc와 동등하며, putc는 매크로로 구현될 수 있는 반면 fputc는 그럴 수 없다.

## 3.7 줄 단위 I/O

줄 단위 입력
        #include <stdio.h>

        char *fgets(char *restrict buf, int n, FILE *restrict fp);
        char *gets(char *buf);
두 함수 모두 한줄을 읽어 들일 버퍼의 주소를 받는다. gets 함수는 표준 입력을 읽는 반면 fgets는 지정된 스트림을 읽는다. </br>
fgets는 n 인수에 버퍼의 크기를 넣어야 한다. 

fputs와 puts 함수는 줄 단위 출력을 수행한다.
        #include <stdio.h>

        int fputs(const char *restrict str, FILE *restrict fp);
        int puts(const char *str);
fputs 함수는 주어진 널 종료 문자열을 주어진 스트림에 기록한다. puts 함수는 주어진 널 종료 문자열을 표준 출력에 기록한다.

## 3.8 표준 I/O의 효율성

