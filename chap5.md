# chapter 5 표준 I/O 라이브러리

## 5.2 스트림과 FILE 객체

표준 I/O 라이브러리에서 파일을 생성하거나 열면 파일 스트림을 얻게 되는데, 이를 "스트림을 파일에 연결시켰다"고 말한다. </br>
표준 I/O 파일 스트림은 단일 바이트 문자 집합과 사용할 수도 있고 다중 바이트 문자 집합과 사용할 수도 있다. </br>
문자가 단일 바이트로 접근되는지 다중 바이트로 접근 되는지를 결정하는 것은 스트림의 지향이다. 한 스트림이 처음 생성되었을 때에는 스트림에 지향이 없는 상태이다. </br>
지향이 없는 스트림에 대해 다중 바이트 I/O 함수가 호출되면 스트림의 지향은 넓은 문자 지향이 된다. </br>
지향이 없는 스트림에 바이트 I/O 함수가 호출되면 스트림의 지향은 바이트 지향이 된다. </br>
fropen 함수로는 스트림의 지향을 지울 수 있고, fwide 함수로는 스트림의 지향을 설정할 수 있다.
    #include <stdio.h>
    #include <wchar.h>

    int fwide(FILE *fp, int mode);
fwide 함수의 행동은 mode 인수에 주어진 값에 따라 달라진다. </br>
1. mode가 음수이면 fwide는 지정된 스트림을 바이트 지향으로 설정하려고 한다.
2. mode가 양수이면 fwide는 지정된 스트림을 넓은 문자 지향으로 설정하려고 한다.
3. mode가 0이면 fwide는 지향을 설정하지 않고 그냥 스트림의 현재 지향을 뜻하는 값을 돌려준다. </br>
지향이 이미 설정되어 있는 스트림에 대해서는 fwide가 지향을 변경하지 않음을 주의해야 한다. 또한 이 함수가 오류코드를 반환하지 않는다는 것도 중요하다. </br>
표준 I/O 함수 fopen으로 스트림을 열면 fopen은 FILE 객체를 가리키는 포인터를 돌려준다. </br>
FILE은 표준 I/O 라이브러리가 스트림을 관리하는 데 필요한 모든 정보를 담은 하나의 구조체이다. 그러한 정보에는 실제 I/O에 쓰이는 파일 서술자, 스트림을 위한 버퍼를 가리키는 포인터, 그 버퍼의 크기, 버퍼에 현재 들어 있는 문자 개수, 오류 플래그 등이 포함된다. </br>
스트림을 사용할 때에는 그냥 해당 FILE 포인터를 각 표준 I/O 함수의 인수로 지정하면 된다.

## 5.3 표준 I/O 스트림들 - 표준 입력, 표준 출력, 표준 오류

모든 프로세스에는 세 가지의 미리 정의된 스트림들이 자동으로 제공된다. </br>
이 스트림들은 표준 파일 서술자 STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO와 동일한 파일들을 가리킨다. </br>
프로그램 안에서는 이 세 표준 I/O 스트림들을 미리 정의된 파일 포인터 stdin, stdout, stderr로 참조한다. 

## 5.4 버퍼링

표준 I/O 라이브러리가 제공하는 버퍼링의 목표는 read 호출과 write 호출의 횟수를 최소화하는 것이다. </br>
표준 I/O 라이브러리는 각 I/O 스트림에 대해 버퍼링을 자동으로 적용함으로써 프로그래머가 버퍼링에 신경 쓰는 일이 없도록 한다. 

표준 I/O 라이브러리에서 제공하는 버퍼링은 다음과 같다.

1. 전체 버퍼링. 이 경우 실제 I/O는 표준 I/O 버퍼가 꽉 찼을 때에만 일어난다. 보통의 경우 표준 I/O 라이브러리는 디스크에 있는 파일들에 이 전체 버퍼링을 적용한다. </br>
전체 버퍼링에 쓰이는 버퍼는 주어진 한 스트림에 대해 I/O가 처음 수행될 때 표준 I/O 함수가 malloc을 호출해서 할당한다. </br>
표준 I/O 버퍼의 내용을 디스크에 기록하는 작업을 방출이라고 한다. 버퍼는 표준 I/O 루틴이 자동으로 방출할 수도 있고, 프로그램의 fflush 호출에 의해 명시적으로 방출될 수도 있다. </br>
UNIX 환경에서 방출은 표준 I/O 라이브러리의 맥락에서는 버퍼 내용의 기록을 의미하지만, 터미널 드라이버의 맥락에서는 버퍼에 저장되어 있는 자료의 폐기를 의미한다. 
2. 줄 단위 버퍼링. 이 경우 표준 I/O 라이브러리는 입력이나 출력에서 새줄 문자를 만났을 때 I/O를 수행한다. 이 버퍼링 하에서 텍스트를 출력할 때 실제 I/O는 하나의 줄이 완성되었을 때만 일어나므로, 텍스트를 한 번에 한 문자씩만 출력해도 성능이 크게 떨어지지 않는다. </br>
줄 단위 버퍼링은 터미널을 가리키는 스트림에 주로 쓰인다. </br>

줄 단위 버퍼링에서는 다음을 주의해야 한다. </br>
1. 표준 I/O 라이브러리가 각 줄의 버퍼링에 사용하는 버퍼의 크기는 고정되어 있으며, 새줄 문자가 나타나기 전에라도 버퍼가 꽉 차면 실제 I/O가 수행된다.
2. 표준 I/O 라이브러리를 통해서 (a) 버퍼링 되지 않는 스트림이나 (b) 줄 단위 버퍼링 스트림으로부터의 입력이 요청되면, 줄 단위 버퍼링 출력 스트림들이 모두 방출된다.
단, (b)는 자료를 커널이 요청한 경우에만 해당한다. 요청된 자료가 이미 버퍼에 들어 있어서 커널이 자료를 읽을 필요가 없는 경우에는 해당하지 않는다. (a)의 경우, 즉, 버퍼링이 없는 스트림에서는 모든 입력에 대해 커널이 자료를 읽어야 한다.
3. 버퍼링 없음. 이 경우 표준 I/O 라이브러리는 문자들을 버퍼링하지 않는다. 보통의 경우 표준 오류 스트림은 버퍼링되지 않는다. </br>
ISO C는 다음을 요구한다. (1. 표준 입력과 표준 출력은 전체 버퍼링이어야 한다. 2. 표준 오류는 결코 전체 버퍼링이 아니다.)
대부분의 구현들은 다음과 같다. (1. 표준 오류는 항상 버퍼링되지 않는다. 2. 그 외의 스트림들은 터미널 줄을 가리키는 경우에는 줄 단위 버퍼링이고 그렇지 않으면 전체 버퍼링이다.)

기본 버퍼링 방식이 적합하지 않은 스트림이 있다면 다음 두 함수를 사용해 스트림의 버퍼링 방식을 변경할 수 있다.
    #include <stdio.h>

    void setbuf(FILE *restrict fp, char *restrict buf);
    int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
이 함수들은 반드시 스트림을 연 후(두 함수 모두 첫 인수로 유효한 파일 포인터를 받으므로 당연한 일이다), 그러나 스트림에 대해 다른 연산을 수행하기 전에 호출해야 한다. </br>
setbuf로는 버퍼링을 켜거나 끌 수 있다. 버퍼링을 켜려면 길이가 BUFSIZ인 버퍼를 가리키는 포인터를 buf 인수에 지정해야 한다. 그러면 fp가 가리키는 스트림에 대해 전체 버퍼링이 설정되는 것이 보통이나, 스트림이 터미널 장치에 연관되어 있다면 줄 단위 버퍼링을 설정하는 구현도 있다. </br>
버퍼링을 끄려면 buf에 NULL을 넣으면 된다. 

버퍼는 언제라도 방출 가능하다. 
    #include <stdio.h>

    int fflush(FILE *fp);
이 함수는 스트림에 대해 아직 기록되지 않은 자료를 커널에 넘겨준다. 
