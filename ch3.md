# chapter 3 파일 입출력
UNIX 시스템에서는 대부분의 파일 입출력을 open, read, write, lseek, close라는 다섯 함수만으로 수행할 수 있고, 여러 가지 버퍼 크기들이 read 함수나 write 함수에 미치는 영향도 살펴본다. </br>
"버퍼링 없는"이라는 용어는 read나 write를 호출할 때마다 매번 커널 안의 시스템 호출이 실행됨을 의미한다. </br>
동일한 자원을 여러 프로세스가 공유하는 상황에서는 항상 원자적 연산이라는 개념이 중요하다. 

## 3.2 파일 서술자
커널에서는 열린 파일들을 항상 파일 서술자를 통해서 지칭한다. 파일 서술자는 음이 아닌 정수이다. </br>
기존 파일을 열거나 새 파일을 생성할 때 커널은 해당 파일에 대한 파일 서술자를 프로세스에게 돌려준다. 파일을 읽거나 쓸 때에는 open이나 creat가 돌려준 파일 서술자를 read나 write의 인수로 넘겨주어서 해당 파일을 지정한다. </br>
UNIX 시스템 셸은 파일 서술자 0을 프로세스의 표준 입력에 연관시키고 파일 서술자 1은 표준 출력에 파일 서술자 2는 표준 오류에 연관시킨다. </br>
POSIX 준수 응용 프로그램에서는 가독성 향상을 위해 STDIN_FILENO와 STDOUT_FILENO, STDERR_FILENO를 사용하는 것이 바람직하다. 파일 서술자의 범위는 0에서 OPEN_MAX-1까지이다.

## 3.3 open 함수와 openat 함수
파일을 열거나 생성할 때에는 open 함수나 openat 함수를 사용한다. </br>
#include <fcntl.h> </br>
int open(const char *path, int oflag, ... /* mode_t mode */ ); </br>
int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ ); </br>
마지막 인수가 ...로 되어 있는데, 이는 ISO C에서 나머지 인수들의 개수와 형식들이 가변적임을 명시하는 방식이다. 새 파일을 생성할 때에만 쓰인다. 

path 매개변수는 열거나 생성할 파일의 이름이다. oflag 인수를 통해서 원하는 옵션을 지정할 수 있다. 다음은 <fcntl.h> 헤더에 있는 상수들이다. </br>

O_RDONLY : 읽기전용 | O_WRONLY : 쓰기 전용 | O_RDWR : 읽기 및 쓰기 용도 | O_EXEC : 실행 전용 | O_SEARCH : 검색 전용(디렉터리에 해당) </br>
위의 다섯 상수 중 하나를 반드시 지정해야 하고 단 하나만 지정해야 한다. 다음 상수들은 선택적으로 지정해도 된다. </br>

O_APPEND : 파일 쓰기 시 자료를 파일의 끝에 추가한다. | O_CLOSEXEC : FD_CLOSEXEC 파일 서술자 플래그를 설정한다. | O_CREAT : 파일이 존재하지 않으면 새로 생성한다. 이 옵션을 지정하려면 open 함수의 셋째 인수 mode도 함께 지정해야 한다. 그 인수는 새 파일의 접근 권한 비트들을 의미한다. | O_DIRECTORY : path가 디렉터리를 가리키지 않으면 오류를 발생한다. | O_EXCL : O_CREAT를 지정했는데 해당 파일이 이미 존재하면 오류를 발생한다. 이 검사는 파일이 이미 존재하는지, 그리고 파일이 존재하지 않을 때 파일 생성이 원자적 연산인지의 여부를 판정한다. O_NOCTTY : path가 터미널 장치를 가리키는 경우 그 장치를 이 프로세스의 제어 터미널로 할당하지 않는다. | O_NOFOLLOW : path가 기호 링크를 가리키면 오류를 발생한다. | O_NONBLOCK : path가 FIFO나 블록 특수 파일, 문자 특수 파일을 가리키는 경우 이 옵션은 파일 열기와 이후 의 입출력 연산 모두에 대한 비차단 모드를 설정한다. | O_SYNC : 각각의 write 호출이 물리적 입출력 연산의 완료를 기다리게 한다. | O_TRUNC : 이미 존재하는 파일을 쓰기 전용이나 읽기 쓰기 용도로 열었을 때 그 파일의 길이를 0으로 줄인다. | O_TTY_INIT : 이미 열려 있지 않은 터미널 장치를 열었을 때 비표준 termios 매개변수를 장치가 단일 UNIX 규격을 준수하는 방식으로 작동하게 만드는 값으로 설정한다. </br>
다음 두 플래그는 단일 UNIX 규격의 동기화 입출력 옵션의 일부이며, 선택적이다. </br>
O_DSYNC : 각 write 연산이 물리적 입출력의 완료를 기다리게 하되, 파일 특성들이 방금 기록한 자료를 읽는 능력에 영향을 미치지 않는다면 파일 특성들의 갱신은 기다리지 않는다. | O_RSYNC : 파일 서술자에 대한 각 read 연산이 파일의 동일한 부분에 대해 진행 중인 쓰기 연산들이 모두 끝날 때까지 기다리게 한다. </br>

fd 매개변수는 openat 함수가 open 함수와 차별화되는 특징이다. 이 매개변수는 상황에 따라 다음과 같이 쓰인다. </br>
1. path 인수에 절대 경로이름을 지정한 경우 fd는 무시되며, openat은 open과 동일하게 작동한다. </br>
2. path 인수에 상대 경로이름을 지정한 경우 fd는 파일 시스템에서 그 상대 경로이름을 평가하는 기준이 되는 시작 위치를 의미한다. 따라서 상대 경로이름을 평가할 기준 디렉터리를 열어서 얻은 파일 서술자를 fd인수로 지정해야 한다. </br>
3. path 인수에 상대 경로이름을 지정하고 fd에는 AT_FDCWD라는 특별한 값을 지정할 수도 있다. 그러면 지정된 상대 경로이름은 현재 작업 디렉터리를 기준으로 평가되며, openat은 open 함수와 동일하게 작동한다.

openat 함수는 첫째로 현재 작업 디렉터리 이외의 디렉터리를 기준으로 상대 경로이름을 지정해서 파일을 열 수 있게 한다. 둘째로 점검 시간 대 사용 시간 오류(TOCTTOU)를 피하는 수단을 제공한다. </br>
TOCTTOU 오류는 응용 프로그램이 파일 기반 함수를 두번 호출하는데 둘째 호출이 첫째 호출의 결과에 의존하는 경우 발생하는 프로그램 취약점을 뜻한다. </br>
파일 시스템 이름 공간 안에서 TOCTTOU 오류는 주로 특권을 가진 프로그램을 속여서 파일 시스템 권한들을 변조하려는 목적으로 악용된다.

## 3.4 creat 함수
새 파일을 creat 함수를 호출해서 생성할 수도 있다. </br>
#include <fcntl.h> </br>
int creat(const char *path, mode_t mode); </br>

open(path, O_WRONLY | O_CREAT | O_TRUNC, mode); creat 함수는 다음 호출과 동일하다. </br>
creat의 단점은 파일을 오직 쓰기 전용으로만 열 수 있다는 점이다. 만일 임시 파일을 생성해서 뭔가를 기록하고 다시 읽으려면 O_WRONLY를 O_RDWR로 바꾸고 호출해야 한다.

## 3.5 close 함수
열린 파일을 닫을 때에는 close 함수를 호출한다. </br>
#include <unistd.h> </br>
int close(int fd); </br>
파일을 닫으면 프로세스가 그 파일에 대해 잠가 두었던 레코드 자물쇠들도 모두 해제된다. 프로세스가 종료되면 프로세스에 열려 있던 모든 파일을 커널이 자동으로 닫는다. 이때문에 열린 파일들을 명시적으로 닫지 않는 프로그램들이 많다.

## 3.6 lseek 함수
모든 열린 파일에는 '현재 파일 오프셋'이 있다. 보통의 경우 파일 오프셋은 파일 시작에서부터 센 바이트 수를 의미하는 음이 아닌 정수이다. </br>
일반적으로 읽기나 쓰기 연산은 현재 파일 오프셋에서 시작하며, 읽거나 기록한 바이트 개수에 따라 현재 파일 오프셋이 증가된다. 기본적으로 이 오프셋은 파일을 열었을 때 0으로 초기화된다. </br>
열린 파일의 오프셋을 명시적으로 설정할때에는 lseek 함수를 사용한다. </br>
#include <unistd.h> </br>
off_t lseek(int fd, off_t offset, int whence); </br>

offset 인수의 해석 방식은 whence 인수의 값에 따라 다르다. </br>
1. whence가 SEEK_SET이면 파일의 오프셋은 파일 시작에서부터 바이트 offset개만큼 나아간 위치로 설정된다. </br>
2. whence가 SEEK_CUR이면 파일의 오프셋은 현재 오프셋 위치 더하기 offset에 해당하는 위치로 설정된다. 이제 offset은 양수일 수도 있고 음수일 수도 있다. </br>
3. whence가 SEEK_END이면 파일의 오프셋은 파일 크기 더하기 offset으로 설정된다. 이때 offset은 양수일 수도 있고 음수일 수도 있다.

lseek 호출이 성공하면 새 파일 오프셋이 반환되므로, 오프셋 바이트 수를 0으로 설정하고 기준 위치를 현재 위치로 설정하면 현재 오프셋을 알아낼 수 있다. </br>
특정 장치에서는 현재 오프셋이 음의 정수일 수 있지만, 정규 파일에서는 오프셋이 반드시 음이 아닌 정수이다. 음의 오프셋이 가능하므로, 오류 처리를 위해 lseek의 반환값을 점검할 때 0보다 작은지 비교하지 말고 -1과 같은지 비교해야 한다. </br>
lseek는 커널 안에서 현재 파일 오프셋만 기록할 뿐 그 어떤 입출력 연산도 유발하지 않는다. 그 오프셋은 다음 번 읽기나 쓰기 연산에 쓰인다. 

파일의 오프셋이 파일의 현재 크기보다 클 수 있다. 그런 파일에 대해 write를 호출하면 파일이 적절히 확장된다. 그러면 소위 파일에 구멍이 생기는 결과가 나오는데 UNIX 파일 시스템들은 이런 구멍 생성을 허용한다. </br>
파일의 구멍이 실제로 디스크상의 공간을 반드시 차지하는 것은 아니다. 파일 시스템 구현에 따라서는 파일 끝을 지나친 위치로 오프셋을 옮겨서 새 자료를 기록한 경우 새 자료를 저장하기 위해 새 디스크 블록을 할당해야 할 수 있지만 </br>
기존의 파일 끝에 있는 자료와 새로 기록된 자료 사이의 자료를 위해 디스크 블록을 할당할 필요는 없다. </br>

파일의 구멍의 내용을 확인할때는 od -c라는 명령을 사용한다. -c 플래그는 내용을 문자로 표시하라는 뜻이며, 파일 중간의 기록되지 않은 바이트들이 0으로 읽혔음을 알 수 있다. </br>
lseek가 사용하는 오프셋 주소는 off_t 형식으로 표현되므로, 구현은 이 형식을 자신의 특정한 플랫폼에 적합한 크기로 설정할 수 있다. 요즘 플랫폼들 대부분은 파일 오프셋 조작을 위해 두 종류의 인터페이스 집합을 제공한다. </br>
하나는 32비트 파일 오프셋을 사용하는 인터페이스들로 이루어진 집합. 또 하나는 64비트 파일 오프셋을 사용하는 인터페이스들로 이루어진 집합이다. 

## 3.7 read 함수
열린 파일로부터 자료를 읽어 들일 때에는 read 함수를 사용한다. </br>
#include <unistd.h> </br>
ssize_t read(int fd, void *buf, size_t nbytes); </br>
read 호출이 성공하면 읽어 들인 바이트 개수가 반환된다. </br>
다음과 같은 경우들에서는 실제로 읽어 들인 바이트 수가 셋째 인수로 요청한 바이트 수보다 적을 수 있다. </br>
1. 정규 파일을 읽는데 요청된 수의 바이트들을 모두 읽기 전에 파일 끝에 도달한 경우
2. 터미널 장치를 읽는 경우
3. 네트워크에서 자료를 읽을 때
4. 파이프나 FIFO를 읽을 때
5. 레코드 지향적 장치를 읽을 때
6. 요청된 크기의 일부만 읽은 상태에서 신호에 의해 연산이 가로채였을 때

읽기 연산은파일의 현재 오프셋에서 시작한다. 읽기가 성공한 경우 호출이 반환되기 전에 오프셋이 실제로 읽은 바이트 수만큼 증가한다.

POSIX.1은 read 함수의 원형을 여러가지 방식으로 변경했다.
1. 둘째 인수가 char *에서 void *로 바뀌었다.
2. 양의 바이트 개수와 0뿐만 아니라 -1을 돌려줄 수 있게 하기 위해 반환값이 부로 있는 정수 형식이어야 함을 명확히 했다.
3. 부호 있는 반환값을 제공하기 위해 기본 시스템 자료 형식 ssize_t가 도입되고 부호 없는 size_t 형식이 셋째 인수에 쓰였다.

## 3.8 write 함수
열린 파일에 자료를 기록할 때에는 write 함수를 사용한다. </br>
#include <unistd.h> </br>
ssize_t write(int fd, const void *buf, size_t nbytes); </br>
보통의 경우 반환값은 nbytes 인수와 동일하다. 그렇지 않다면 오류가 발생한 것이다. </br>
디스크에 남은 용량이 없거나 주어진 프로세스에 대한 파일 크기 한계를 넘었을 때 write가 오류를 발생한다. </br>
정규 파일에 대한 쓰기 연산은 파일의 현재 오프셋에서 시작한다. 지정된 파일을 열 때 O_APPEND 옵션을 지정했다면, 각 호출마다 먼저 파일 오프셋이 파일의 현재 끝으로 설정된 후에 쓰기 연산이 진행된다. </br>
쓰기 연산이 성공하면 파일의 오프셋이 실제로 기록된 바이트 수만큼 증가한다.

## 3.9 입출력 효율성
통상적인 UNIX 시스템 셸들은 모두 표준 입력 읽기를 위해 파일을 여는 수단과 표준 출력에 대해 파일을 생성(또는 덮어쓰기)하는 수단을 제공한다. 이 덕분에 프로그램이 입력 파일과 출력 파일을 직접 열 필요가 없으며, 또한 사용자가 셸의 입출력 재지정 기능을 활용할 수 있게 된다. </br>
대부분의 파일 시스템은 성능 향상을 위해 일종의 미리 읽기 기법을 지원한다. 그런 파일 시스템은 순차적인 읽기 연산들을 검출한 경우 응용 프로그램이 요청한 것보다 더 많은 자료를 읽어 들인다. 

## 3.10 파일 공유
UNIX 시스템에서 여러 프로세스들이 열린 파일들을 공유하는 것이 가능하다. 커널은 열린 파일 하나를 세가지 자료구조의 조합으로 관리한다. </br>
파일 공유에 관해서 한 프로세스가 다른 프로세스에 미치는 영향은 세 자료구조 사이의 관계에 의해 결정된다. </br>
1. 커널의 프로세스 테이블에는 시스템의 모든 프로세스마다 각각 하나씩의 항목이 있다. 프로세스 테이블의 한 항목에는 열린 파일 서술자들의 테이블이 있는데, 그것을 서술자당 하나의 항목으로 이루어진 벡터라고 생각해도 된다. </br>
  a) 파일 서술자 플래그들 </br>
  b) 파일 테이블 항목을 가리키는 포인터 </br>
2. 커널은 모든 열린 파일에 대한 파일 테이블 하나를 관리한다. </br>
  a) 파일에 대한 파일 상태 플래그들
  b) 현재 파일 오프셋
  c) 파일에 대한 v-노드 테이블을 가리키는 포인터
3. 각각의 열린 파일(또는 장치)마다 하나씩의 v-노드 자료구조가 존재한다. v-노드에는 파일의 종류에 관한 정보 및 그 파일에 대해 작동하는 함수들을 가리키는 포인터들이 담겨 있다. </br>
커널은 이러한 정보를 파일을 열 때 디스크에서 읽어 온다. 따라서 파일이 성공적으로 열렸다면 필요한 정보가 이미 준비되어 있는 것이다. </br>
파일 서술자 플래그들과 파일 상태 플래그들의 적용 범위에 차이가 있다. 전자는 오직 한 프로세스의 한 서술자에만 적용되는 반면 후자는 주어진 파일 테이블 항목을 가리키는 모든 프로세스의 모든 서술자에 적용된다.

## 3.11 원자적 연산
각 프로세스는 자신만의 파일 테이블 항목과 자신만의 현재 파일 오프셋을 가지기 때문에 여러 프로세스들이 같은 파일을 읽는 경우에는 잘 작동한다. </br>
그러나 여러 프로세스가 같은 파일에 자료를 기록할 때에는 예기치 못한 결과가 나올 수 있는데 그런 예기치 못한 사태를 피하기 위해서는 원자적 연산을 이해해야 한다. </br>
if (lseek(fd, 0L, 2) < 0)  /* 오프셋을 EOF로 옮기고 */ </br>
  err_sys("lseek error"); </br>
if (write(fd, buf, 100) != 100)  /* 기록한다. */ </br>
  err_sys("write error"); </br>
하나의 프로세스가 파일 끝에 자료를 추가하려면 open 함수가 O_APPEND 플래그를 지원하지 않았기 때문에 프로그램을 위와 같이 코딩했다. 이 방법은 여러 프로세스가 이처럼 파일에 자료를 추가하면 문제가 발생한다. </br>
문제는 '파일 끝으로 가서 자료를 기록한다'라는 논리적인 연산에 실제로는 두 개의 개별적인 함수 호출이 필요하다는 점이다. 해결책은 현재의 파일 끝으로 가서 자료를 기록하는 연산을 하나의 원자적인 연산으로 만드는 것이다. </br>
둘 이상의 함수 호출이 필요한 연산은 원자적인 연산이 될 수 없다. 두 함수 호출 사이에 커널이 프로세스를 잠시 보류할 가능성이 항상 존재하기 때문이다. </br>
UNIX 시스템은 이러한 연산을 원자적으로 수행하는 방법을 제공한다. 바로, 파일을 열 때 O_APPEND 플래그를 지정하는 것이다. 이 플래그를 설정하면 커널은 write 호출 시 자동으로 파일 오프셋을 파일 끝으로 옮긴 후에 자료를 기록한다. 각 호출마다 먼저 lseek를 호출할 필요가 없는 것이다. </br>

### pread 함수와 pwirte 함수
단일 UNIX 규격에는 응용 프로그램이 파일 탐색과 읽기 또는 쓰기 연산을 원자적으로 수행할 수 있게 하는 함수 두개가 포함되어 있다. 바로 pread 함수와 pwrite 함수이다. </br>
#include <unistd.h> </br>
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset); </br>
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset); </br>
pread를 호출하는 것은 먼저 lseek를 호출한 후 read를 호출하는 것과 동등하되 아래와 같은 점들이 다르다. </br>
1. pread의 경우에는 두 연산 사이에 가로채기가 일어날 여지가 없다.
2. 현재 파일 오프셋이 갱신되지 않는다.

### 파일 생성
O_CREAT와 O_EXCL 옵션을 모두 지정한 경우 open의 호출은 오직 파일이 이미 존재하는 경우에만 실패한다. </br>
if ((fd = open(path, O_WRONLY)) < 0) { </br>
  if (errno == ENOENT) { </br>
    if ((fd = creat(path, mode)) < 0) </br>
      err_sys("creat error"); </br>
  } else { </br>
    err_sys("open error"); </br>
  } </br>
} </br>
open 호출과 creat 호출 사이에 다른 어떤 프로세스가 같은 이름의 파일을 생성해 버리면 문제가 발생한다. 만일 두 호출 사이에 다른 프로세스가 그 파일을 생성한다면, 그리고 그 프로세스가 파일에 어떤 자료를 기록한다면, 이 프로세스의 creat가 실행될 때 그 자료가 삭제된다. 파일의 존재 여부 점검과 생성을 하나의 원자적 연산으로 결합하면 이런 문제가 생기지 않는다. </br>
원자적 연산은 여러 단계로 나뉘어 실행될 수 있는, 그리고 모든 단계가 수행되거나(성공 시) 아니면 그 어떤 단계도 수행되지 않는다는(실패 시) 조건을 만족하는 연산을 뜻한다. 즉, 단계들 중 일부만 수행되는 것이 불가능해야 한다. 

## 3.12 dup 함수와 dup2 함수
기존 파일 서술자를 복제할 때 사용할 수 있는 두 함수이다. </br>
#include <unistd.h> </br>
int dup(int fd); </br>
int dup2(int fd, int fd2); </br>
dup가 돌려주는 파일 서술자는 가장 낮은 번호의 서술자임이 보장된다. dup2의 경우에는 호출 시 새 서술자의 값을 fd2 인수로 지정한다. fd2가 이미 열려 있으면 먼저 닫힌 후 복제가 일어난다. </br>
만일 fd가 fd2와 같으면 dup2는 fd2를 닫지 않고 돌려준다. 같지 않으면 fd2에 대한 FD_CLOSEXEC 파일 서술자 플래그가 해제되며, 따라서 exec를 호출해도 fd2는 열린 채로 남는다. 
dup2(fd, fd2)와 close(fd2); </br>
                fcntl(fd, F_DUPED, fd2); </br>
위의 경우는 차이가 있다. dup2는 원자적 연산인 반면, 후자의 대안은 두 번의 함수 호출로 이루어진다. 따라서 후자의 경우 close 호출과 fcntl 호출 사이에 신호 처리부가 호출되어서 파일 서술자가 변할 수도 있다. </br>
dup2와 fcntl은 errno를 설정하는 방식이 조금 다르다. 

## 3.13 sync 함수, fsync 함수, fdatasync 함수
파일에 어떤 자료를 기록할 때 일반적으로 커널은 그 자료를 자신의 버퍼들 중 하나에 복사해 두고, 나중에 적당한 때가 되면 디스크에 기록한다. 이를 지연된 쓰기(delayed write)라고 한다. </br>
결국에는 커널이 지연된 쓰기 블록들을 디스크에 기록하는데, 보통 그 시점은 다른 어떤 디스크 블록을 위해 버퍼를 재사용해야 할 때이다. 디스크상의 파일 시스템과 버퍼 캐시의 내용 사이의 일관성을 보장하기 위해 UNIX 시스템은 sync 함수와 fsync 함수, fdatasync 함수를 제공한다. </br>

#include <unistd.h> </br>
int fsync(inr fd); </br>
int fdatasync(inr fd); </br>

void sync(void); </br>
sync 함수는 모든 수정된 블록 버퍼들을 쓰기 위한 대기열에 등록한 다음 바로 반환된다. 실제로 디스크 쓰기 연산이 실행될 때까지 기다리지 않는다. </br>
일반적으로 sync 함수는 시스템 데몬에 의해 주기적으로 호출된다. 그런 데몬의 이름은 update인 경우가 많은데 이에 의해 커널의 블록 버퍼들이 주기적으로 방출된다. </br>
fsync 함수는 fd 인수로 주어진 파일 서술자에 해당하는 파일 하나에만 적용한다. 이 함수는 그 파일에 대한 디스크 쓰기가 완료될 때까지 기다렸다가 반환된다. 데이터베이스 같은 응용 프로그램에서 수정된 블록이 실제로 디스크에 기록되었음을 보장할 필요가 있을 때 이 함수가 유용하게 사용된다. </br>
fdatasync 함수는 fsync와 비슷하되 파일의 자료에만 영향을 미친다는 점이 다르다. fsync의 경우에는 파일의 특성들도 동기화된다.

## 3.14 fcntl 함수
이미 열린 파일의 속성들을 변경할 수 있다.
#include <fcntl.h> </br>
int fcntl(int fd, int cmd, ... /* int arg */ ); </br>
fcntl 함수는 다섯가지의 서로 다른 용도로 사용된다. </br>
1. 기존 서술자를 복제한다. (cmd = F_DUPFD 또는 F_DUPED_CLOEXEC)
2. 파일 서술자 플래그들을 조회 또는 설정한다. (cmd = F_GETFD 또는 F_SETFD)
3. 파일 상태 플래그들을 조회 또는 설정한다. (cmd = F_GETFL 또는 F_SETFL)
4. 비동기 입출력 소유권을 조회 또는 설정한다. (cmd = F_GETOWN 또는 F_SETOWN)
5. 레코드 자물쇠를 조회 또는 설정한다. (cmd = F_GETLK나 F_SETLK, 또는 F_SETLKW)

fcntl에 쓰이는 상태 플래그들 </br>
1. O_RDONLY : 읽기 전용
2. O_WRONLY : 쓰기 전용
3. O_RDWR : 읽기 및 쓰기 용도
4. O_EXEC : 실행 전용
5. O_SEARCH : 검색 전용으로 디렉터리를 연다.
6. O_APPEND : 각 쓰기 시 추가를 적용
7. O_NONBLOCK : 비차단 모드
8. O_SYNC : 쓰기들이 완료되길 기다림(자료 및 특성들)
9. O_DSYNC : 쓰기들이 완료되길 기다림(자료만)
10. O_RSYNC : 읽기들과 쓰기들을 동기화한다.
11. O_FSYNC : 쓰기들이 완료되길 기다림 (FreeBSD와 Mac OS X에서만)
12. O_ASYNC : 비동기 입출력(FreeBSD와 Mac OS X에서만)

F_DUPFD : 파일 서술자 fd를 복제한다. 함수는 새 파일 서술자를 함수의 반환값으로 돌려준다. 새 서술자는 fd와 동일한 파일 테이블 항목을 공유하지만, 새 서술자는 자신만의 파일 서술자 플래그 집합을 가지며, FD_CLOEXEC 파일 서술자 플래그는 해제된 상태이다. </br>
F_DUPFD_CLOEXEC : 파일 서술자를 복제하고, 새 파일 서술자에 연관된 FD_CLOEXEC 파일 서술자 플래그를 설정한다. 새 파일 서술자를 반환한다. </br>
F_GETFD : fd에 대한 파일 서술자 플래그들을 함수의 반환값으로 돌려준다. </br>
F_SETFD : fd에 대한 파일 서술자 플래그들을 설정한다. 새 플래그 값은 셋째 인수로 지정한다. </br>
F_GETFL : fd에 대한 파일 상태 플래그들을 함수의 반환값으로 돌려준다. </br>

다섯가지 접근 모드 플래그들 즉, O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, O_SEARCH는 개별적으로 판정할 수 있도록 분리된 비트들이 아니다. 따라서 반드시 O_ACCMODE 마스크를 이용해서 적절한 접근 모드 비트들을 얻고 그것을 이 다섯 값 중 하나와 비교해야 한다. </br>
F_SETFL : 파일 상태 플래그들을 셋째 인수의 값으로 설정한다. 변경할 수 있는 플래그는 O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, O_ASYNC 뿐이다. </br>
F_GETOWN : 현재 SIGIO 신호와 SIGURG 신호를 받도록 설정된 프로세스 ID 또는 프로세스 그룹 ID를 돌려준다. </br>
F_SETOWN : 지정된 프로세스 ID나 프로세스 그룹 ID가 SIGIO 신호와 SIGURG 신호를 받도록 설정한다. 양의 arg는 프로세스 ID를 뜻하고 음의 arg는 프로세스 그룹 ID를 뜻한다. 

fcntl의 반환값은 cmd로 지정된 명령의 종류에 따라 다르다. 모든 명령은 오류 시 -1을 돌려준다. F_DUPFD, F_GETFD, F_GETFL, F_GETOWN의 반환값은 특별하다. 첫 명령은 새 파일 서술자를 돌려주고, 그 다음 둘은 해당 플래그들을 돌려주고, 마지막 명령은 양의 프로세스 ID 또는 음의 프로세스 그룹 ID를 돌려준다.

## 3.15 ioctl 함수
그 어떤 입출력 연산도 수행할 수 있는 다재다능한 수단이다. 위에 언급한 함수들로는 표현할 수 없는것들도 ioctl로는 가능하다. 가장 큰 용도는 터미널 입출력이다. </br>
#include <unistd.h> /* System V */ </br>
#include <sys/ioctl.h> /* BSD와 Linux */ </br>

int ioctl(int fd, int request, ...); </br>
ioctl 함수는 둘째 인수로는 항상 특정 헤더 파일에 #define으로 정의된 상수 이름을 지정하기 때문이다. </br>
이 원형에는 함수 자체에 필요한 헤더들만 표시되어 있다. 보통은 장치 고유의 헤더들도 필요하다. 각 장치 구동기는 자신만의 ioctl 명령 집합을 정의할 수 있다. 시스템은 서로 다른 부류의 장치들에 대한 일반적 ioctl 명령들을 제공한다. </br>
자기 테이프 명령들을 이용하면 테이프에 파일 끝 표식을 기록하거나, 테이프를 되감거나, 지정된 개수의 파일 또는 레코드만큼 건너뛰는 등의 연산을 할 수 있다. 

# 3.16 /dev/fd
최근 시스템들은 /dev/fd라는 이름의 디렉터리를 제공하는데 이 디렉터리에는 0, 1, 2 등인 파일들이 있다. 파일 서술자 n이 이미 열려 있다고 가정할 때, /dev/fd/n이라는 파일을 여는 것은 서술자 n을 복제하는 것과 동등한 일이다. </br>

대부분의 시스템은 다음과 같은 함수 호출에서 mode 인수로 지정된 파일 열기 모드를 무시한다. -> fd = open("/dev/fd/0", mode); </br>
그러나 반드시 지정된 파일을 열 때 사용한 모드의 부분집합에 해당하는 모드를 지정해야 하는 시스템들도 있다. 위의 open 호출은 fd = dup(0);과 동등하므로, 서술자 0과 fd는 동일한 파일 테이블 항목을 공유한다. </br>
예를 들어 서술자 0을 원래 읽기 전용으로 열었다면 fd에 대해서도 읽기만 가능하다. 즉, 읽기 모드를 무시하는 시스템에서 다음 호출이 성공한다고 해도 fd에 자료를 기록할 수는 없다. fd = open("/dev/fd/0", O_RDWR); </br>
creat 호출 시 /dev/fd를 첫 인수(경로이름)에 사용할 수 있다. O_CREAT를 지정해서 open을 호출할 때에도 마찬가지이고, 이 덕분에 creat를 호출하는 프로그램도 이를테면 /dev/fd/1이 경로이름 인수로 주어졌을 때 여전히 작동한다. </br>
/dev/stdin이나 /dev/stdout, /dev/stderr 같은 경로이름들을 제공하는 시스템들도 있다. 이들은 각각 /dev/fd/0, /dev/fd/1, /dev/fd/2와 동등하다. </br>
/dev/fd 파일들은 주로 셸에 쓰인다. 이들을 이용하면 경로이름 인수들을 사용하는 프로그램들이 표준 입력과 표준 출력을 다른 경로이름들과 동일한 방식으로 취급할 수 있다. 
