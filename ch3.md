# chapter 3 파일 입출력
UNIX 시스템에서는 대부분의 파일 입출력을 open, read, write, lseek, close라는 다섯 함수만으로 수행할 수 있고, 여러 가지 버퍼 크기들이 read 함수나 write 함수에 미치는 영향도 살펴본다. </br>
"버퍼링 없는"이라는 용어는 read나 write를 호출할 때마다 매번 커널 안의 시스템 호출이 실행됨을 의미한다. </br>
동일한 자원을 여러 프로세스가 공유하는 상황에서는 항상 원자적 연산이라는 개념이 중요하다. 

## 3.2 파일 서술자
커널에서는 열린 파일들을 항상 파일 서술자를 통해서 지칭한다. 파일 서술자는 음이 아닌 정수이다. </br>
기존 파일을 열거나 새 파일을 생성할 때 커널은 해당 파일에 대한 파일 서술자를 프로세스에게 돌려준다. 파일을 읽거나 쓸 때에는 open이나 creat가 돌려준 파일 서술자를 read나 write의 인수로 넘겨주어서 해당 파일을 지정한다. </br>
UNIX 시스템 셸은 파일 서술자 0을 프로세스의 표준 입력에 연관시키고 파일 서술자 1은 표준 출력에 파일 서술자 2는 표준 오류에 연관시킨다. </br>
POSIX 준수 응용 프로그램에서는 가독성 향상을 위해 STDIN_FILENO와 STDOUT_FILENO, STDERR_FILENO를 사용하는 것이 바람직하다. 파일 서술자의 범위는 0에서 OPEN_MAX-1까지이다.

## 3.3 open 함수와 openat 함수
파일을 열거나 생성할 때에는 open 함수나 openat 함수를 사용한다. </br>
#include <fcntl.h> </br>
int open(const char *path, int oflag, ... /* mode_t mode */ ); </br>
int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ ); </br>
마지막 인수가 ...로 되어 있는데, 이는 ISO C에서 나머지 인수들의 개수와 형식들이 가변적임을 명시하는 방식이다. 새 파일을 생성할 때에만 쓰인다. 

path 매개변수는 열거나 생성할 파일의 이름이다. oflag 인수를 통해서 원하는 옵션을 지정할 수 있다. 다음은 <fcntl.h> 헤더에 있는 상수들이다. </br>

O_RDONLY : 읽기전용 | O_WRONLY : 쓰기 전용 | O_RDWR : 읽기 및 쓰기 용도 | O_EXEC : 실행 전용 | O_SEARCH : 검색 전용(디렉터리에 해당) </br>
위의 다섯 상수 중 하나를 반드시 지정해야 하고 단 하나만 지정해야 한다. 다음 상수들은 선택적으로 지정해도 된다. </br>

O_APPEND : 파일 쓰기 시 자료를 파일의 끝에 추가한다. | O_CLOSEXEC : FD_CLOSEXEC 파일 서술자 플래그를 설정한다. | O_CREAT : 파일이 존재하지 않으면 새로 생성한다. 이 옵션을 지정하려면 open 함수의 셋째 인수 mode도 함께 지정해야 한다. 그 인수는 새 파일의 접근 권한 비트들을 의미한다. | O_DIRECTORY : path가 디렉터리를 가리키지 않으면 오류를 발생한다. | O_EXCL : O_CREAT를 지정했는데 해당 파일이 이미 존재하면 오류를 발생한다. 이 검사는 파일이 이미 존재하는지, 그리고 파일이 존재하지 않을 때 파일 생성이 원자적 연산인지의 여부를 판정한다. O_NOCTTY : path가 터미널 장치를 가리키는 경우 그 장치를 이 프로세스의 제어 터미널로 할당하지 않는다. | O_NOFOLLOW : path가 기호 링크를 가리키면 오류를 발생한다. | O_NONBLOCK : path가 FIFO나 블록 특수 파일, 문자 특수 파일을 가리키는 경우 이 옵션은 파일 열기와 이후 의 입출력 연산 모두에 대한 비차단 모드를 설정한다. | O_SYNC : 각각의 write 호출이 물리적 입출력 연산의 완료를 기다리게 한다. | O_TRUNC : 이미 존재하는 파일을 쓰기 전용이나 읽기 쓰기 용도로 열었을 때 그 파일의 길이를 0으로 줄인다. | O_TTY_INIT : 이미 열려 있지 않은 터미널 장치를 열었을 때 비표준 termios 매개변수를 장치가 단일 UNIX 규격을 준수하는 방식으로 작동하게 만드는 값으로 설정한다. </br>
다음 두 플래그는 단일 UNIX 규격의 동기화 입출력 옵션의 일부이며, 선택적이다. </br>
O_DSYNC : 각 write 연산이 물리적 입출력의 완료를 기다리게 하되, 파일 특성들이 방금 기록한 자료를 읽는 능력에 영향을 미치지 않는다면 파일 특성들의 갱신은 기다리지 않는다. | O_RSYNC : 파일 서술자에 대한 각 read 연산이 파일의 동일한 부분에 대해 진행 중인 쓰기 연산들이 모두 끝날 때까지 기다리게 한다. </br>

fd 매개변수는 openat 함수가 open 함수와 차별화되는 특징이다. 이 매개변수는 상황에 따라 다음과 같이 쓰인다. </br>
1. path 인수에 절대 경로이름을 지정한 경우 fd는 무시되며, openat은 open과 동일하게 작동한다. </br>
2. path 인수에 상대 경로이름을 지정한 경우 fd는 파일 시스템에서 그 상대 경로이름을 평가하는 기준이 되는 시작 위치를 의미한다. 따라서 상대 경로이름을 평가할 기준 디렉터리를 열어서 얻은 파일 서술자를 fd인수로 지정해야 한다. </br>
3. path 인수에 상대 경로이름을 지정하고 fd에는 AT_FDCWD라는 특별한 값을 지정할 수도 있다. 그러면 지정된 상대 경로이름은 현재 작업 디렉터리를 기준으로 평가되며, openat은 open 함수와 동일하게 작동한다.

openat 함수는 첫째로 현재 작업 디렉터리 이외의 디렉터리를 기준으로 상대 경로이름을 지정해서 파일을 열 수 있게 한다. 둘째로 점검 시간 대 사용 시간 오류(TOCTTOU)를 피하는 수단을 제공한다. </br>
TOCTTOU 오류는 응용 프로그램이 파일 기반 함수를 두번 호출하는데 둘째 호출이 첫째 호출의 결과에 의존하는 경우 발생하는 프로그램 취약점을 뜻한다. </br>
파일 시스템 이름 공간 안에서 TOCTTOU 오류는 주로 특권을 가진 프로그램을 속여서 파일 시스템 권한들을 변조하려는 목적으로 악용된다.

## 3.4 creat 함수
새 파일을 creat 함수를 호출해서 생성할 수도 있다. </br>
#include <fcntl.h> </br>
int creat(const char *path, mode_t mode); </br>

open(path, O_WRONLY | O_CREAT | O_TRUNC, mode); creat 함수는 다음 호출과 동일하다. </br>
creat의 단점은 파일을 오직 쓰기 전용으로만 열 수 있다는 점이다. 만일 임시 파일을 생성해서 뭔가를 기록하고 다시 읽으려면 O_WRONLY를 O_RDWR로 바꾸고 호출해야 한다.

## 3.5 close 함수
열린 파일을 닫을 때에는 close 함수를 호출한다. </br>
#include <unistd.h> </br>
int close(int fd); </br>
파일을 닫으면 프로세스가 그 파일에 대해 잠가 두었던 레코드 자물쇠들도 모두 해제된다. 프로세스가 종료되면 프로세스에 열려 있던 모든 파일을 커널이 자동으로 닫는다. 이때문에 열린 파일들을 명시적으로 닫지 않는 프로그램들이 많다.

## 3.6 lseek 함수
