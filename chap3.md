# Chapter 3 파일 I/O

## 3.2 파일 서술자

커널은 열린 파일들을 파일 서술자라는 값을 통해서 참조한다. </br>
프로세스가 기존 파일의 파일을 열거나 새 파일을 생성하면 커널은 그에 해당하는 파일 서술자를 프로세스에게 돌려준다. </br>
특정한 파일을 읽거나 쓸 때에는 그 파일에 대해 open이나 creat가 돌려준 파일 서술자를 read나 write의 인수로 제공함으로써 해당 파일을 지정한다. </br>
POSIX를 준수하는 응용 프로그램에서는 0, 1, 2라는 마법의 수들을 각각 STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO라는 기호 상수들로 대체해야 한다.

## 3.3 open 함수

파일을 열거나 생성할 때 쓰임.

    #include <fcntl.h>

    int open(const char *pathname, int oflag, ... /* mode_t mode */ );

셋째 인수는 ...으로 표기되어 있는데, 이것은 ISO C에서 나머지 인수들의 개수와 형식들이 가변적임을 나타내는 방법이다. </br>
pathname 인수는 열거나 생성할 파일의 이름이다. oflag는 함수의 작동 방식을 결정하는 다양한 옵션들이다.

    필수적
    O_RDONLY: 읽기 전용으로 연다.
    O_WRONLY: 쓰기 전용으로 연다.
    O_RDWR: 읽기 및 쓰기용으로 연다.

    선택적
    O_APPEND: 파일 기록 시 내용을 파일의 끝에 추가한다.
    O_CREAT: 파일이 존재하지 않으면 새로 생성한다.
    O_EXCL: O_CREAT와 이 상수를 함께 지정하면, 파일이 이미 존재하는 경우에 오류가 발생한다.
    O_TRUNC: 이미 존재하는 파일을 읽기 또는 쓰기 모드로 열었을 때 파일의 크기가 0으로 줄어들게 한다.
    O_NOCTTY: pathname에 터미널 장치를 가리키는 경우, 해당 장치를 이 프로세스의 제어 터미널로 배정하지 않도록 한다.
    O_NONBLOCK: pathname이 FIFO나 블록 특수 파일, 문자 특수 파일을 지칭하는 경우, 이 옵션은 그 파일의 열기 및 이후의 I/O 작업들에 대해 비차단 모드를 설정한다.
    O_DSYNC: 각 write 연산이 물리적 I/O 연산의 완료를 기다리게 하되, 방금 기록한 자료를 읽을 수 있는 능력에 미치지 않는 파일 특성 갱신은 기다리지 않도록 한다.
    O_RSYNC: 파일 서술자에 대한 각 read 연산이 파일의 동일한 부분에 대해 유보된 기록의 완료를 기다리게 한다.
    O_SYNC: 각 write 연산이 물리적 I/O의 완료를 기다리게 한다.

### 파일이름과 경로이름의 절단

POSIX.1에는 함수들이 긴 파일이름과 긴 경로이름을 소리 없이 잘라낼 것인지 아니면 오류를 돌려줄 것인지를 결정하는 _POSIX_NO_TRUNC라는 상수가 있다. </br>
_POSIX_NO_TRUNC가 설정된 상황에서 경로이름의 길이가 PATH_MAX보다 크거나 경로이름의 파일이름 성분이 하나라도 NAME_MAX보다 길면 errno가 ENAMETOOLONG으로 설정되며, 함수는 오류 코드를 반환한다.

## 3.4 creat 함수

새 파일은 creat 함수로도 생성 가능하다.

    #include <fcntl.h>

    int creat(const char *pathname, mode_t mode);

open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode); -> creat 함수는 다음 호출과 동일하다.

## 3.5 close 함수

열린 파일을 닫을 때는 close 함수를 호출한다.

    #include <unistd.h>

    int close(int filedes);

파일을 닫으면 프로세스가 그 파일에 대해 잠근 레코드 자물쇠들도 모두 해제된다. </br>
프로세스가 종료되면 커널이 프로세스의 열린 파일들을 모두 자동으로 닫는다.

## 3.6 lseek 함수

모든 열린 파일에는 "현재 파일 오프셋"이 존재한다. 파일 오프셋은 파일의 시작에서부터 센 바이트 수 에 해당하는 음이 아닌 정수이다. </br>
보통의 경우 읽기, 쓰기 연산들은 현재 파일 오프셋에서 시작하며, 연산이 끝나면 읽거나 쓴 바이트 수만큼 오프셋이 증가한다. O_APPEND를 지정하지 않은 이상, 파일을 열면 오프셋이 0으로 초기화된다. </br>
열린 파일의 오프셋을 명시적으로 변경할 때는 lseek 함수를 사용한다.

    #include <unistd.h>

    off_t lseek(int filedes, off_t offset, int whence);

offset에 주어진 값의 적용 방식은 whence 인수에 주어진 값에 따라 다르다. </br>
1. whence가 SEEK_SET이면 파일의 오프셋은 offset으로 설정된다. </br>
2. whence가 SEEK_CUR이면 파일의 오프셋은 현재 값에 offset을 더한 값으로 설정된다. </br>
3. whence가 SEEK_END이면 파일의 오프셋은 파일의 크기 더하기 offset으로 설정된다.

호출 성공 시 lseek 함수는 새 파일 오프셋을 돌려주므로 현재 위치로부터 0 떨어진 곳을 찾음으로써 현재 오프셋의 값을 알아낼 수 있다.

lseek은 커널 안에서 현재 파일 오프셋을 기록하기만 할 뿐, 실제로 I/O 연산을 일으키지는 않는다. 오프셋은 이후 실제의 읽기, 쓰기 연산에 쓰인다. </br>
파일의 오프셋이 파일의 현재 크기보다 클 수 있다. 그런 경우 그 파일에 대한 다음 번 write에 의해 파일의 크기가 적절히 커진다. 파일에 명시적으로 기록되지 않은 부분을 구멍(hole)이라고 하는데, UNIX 시스템에서는 이러한 구멍 생성을 허용함.

lseek이 사용하는 오프셋의 형식은 off_t이다. 구현은 이 형식을 적절히 정의함으로써  파일 오프셋의 크기를 자신의 요구에 맞게 설정할 수 있다.

## 3.7 read 함수

열린 자료에서 자료를 읽을 때에는 read 함수를 사용한다.

        #include <unistd.h>

        ssize_t read(int filedes, void *buf, size_t nbytes);

read 호출이 성공하면 실제로 읽은 바이트 수가 반환된다. 파일의 끝을 읽으려 한 경우에는 0이 반환된다.

## 3.8 write 함수

열린 파일에 자료를 기록할 때에는 write 함수를 사용한다.

        #include <unistd.h>

        ssize_t write(int filedes, const void *buf, size_t nbytes);

보통의 경우 반환값은 nbytes 인수와 같고 그렇지 않으면 오류가 발생한 것이다. </br>
write가 실패하는 흔한 원인으로는 디스크에 남은 용량이 없거나 주어진 프로세스에 대한 파일 크기 상한을 넘는 경우 등을 들 수 있다.

## 3.9 I/O 효율성

(ex3.3)

이 프로그램은 표준 입력에서 자료를 읽어 그것을 표준 출력에 기록하는데, 프로그램이 실행되기 전에 셸이 표준 입력과 표준 출력을 설정해 두었다고 가정한다. </br>
UNIX 시스템 셸들은 모두 표준 입력의 읽기를 위해 파일을 여는 수단과 표준 출력에 대한 기록을 위해 파일을 생성하는 수단을 제공한다. 이 덕분에 프로그램이 입력 파일과 출력 파일을 직접 열 필요가 없다. </br>
이 프로그램은 입력 파일이나 출력 파일을 닫지 않지만, 프로세스 종료 시 UNIX 커널이 모든 열린 파일 서술자를 닫는다는 사실에 의존한다.

## 3.10 파일 공유

UNIX 시스템은 열린 파일들을 서로 다른 프로세스들이 공유할 수 있는 기능을 제공한다.

커널이 하나의 열린 파일을 다루는데에는 다음의 세가지 자료구조들이 관여한다. 이 세 자료구조들 사이의 관계는 파일 공유와 관련해서 한 프로세스가 다른 프로세스에 미치는 영향을 결정한다.

1. 커널은 시스템의 모든 프로세스에 대한 정보를 담은 프로세스 테이블을 관리한다. 각 프로세스는 이 테이블의 한 항목을 차지한다. </br>
2. 커널은 모든 열린 파일에 대한 정보를 담은 파일 테이블을 관리한다. 파일 테이블의 각 항목마다 다음과 같은 정보가 담긴다. </br>
(a) 파일의 상태 플래그들(읽기, 쓰기, 추가, 동기화, 비차단) </br>
(b) 현재 파일 오프셋 </br>
(c) 파일의 v노드 테이블 항목으로의 포인터 </br>

3. 열린 파일마다 파일의 종류 및 파일에 대해 작동하는 함수들로의 포인터들을 담은 v노드 구조체가 존재한다.

## 3.11 원자적 연산들

파일 끝에 자료 추가

UNIX 시스템의 예전 버전들에서는 open 함수가 O_APPEND를 지원하지 않았기 때문에 다음과 같은 코드를 사용해야 했다.

        if (lseek(fd, 0L, 2) < 0)
            err_sys("lseek error");    /* 오프셋을 EOF로 옮기고 */
        if (write(fd, buf, 100) != 100)
            err_sys("Write error");    /* 자료를 기록한다. */

하나의 프로세스라면 이 방법이 통하지만 여러 프로세스가 이런 방법으로 같은 파일에 자료를 추가하려고 하면 문제가 발생한다. </br>
"파일의 끝으로 가서 자료를 기록한다"라는 하나의 논리적인 연산이 두 개의 개별적인 함수 호출을 필요로 한다는 점에서 비롯된다. </br>
해결책은 현재 파일 끝으로의 이동과 자료 기록을 다른 프로세스들에 대해 하나의 원자적인 연산으로 만드는 것이다. </br>
둘 이상의 함수 호출을 요구하는 연산은 원자적 연산이 될 수 없다. 두 함수 호출 사이에서 커널이 프로세스를 일시 정지시킬 가능성이 항상 존재하기 때문이다. </br>
UNIX 시스템에서는 파일을 열 때 O_APPEND를 지정하면 이러한 연산이 원자적으로 수행된다. O_APPEND를 지정하면 커널은 각 write 호출 전에 파일 오프셋을 현재 파일 끝으로 이동한다. 따라서 write를 호출할 때마다 lseek을 호출할 필요가 없다.

pread와 pwrite 함수

단일 UNIX 규격에는 응용프로그램이 파일 탐색과 I/O 연산을 원자적으로 수행할 수 있게 하는 XSI 확장들이 포함되어 있다. pread와 pwrite 함수가 그것이다. </br>
        #include <unistd.h>

        ssize_t pread(int filedes, void *buf, size_t nbytes, off_t offset);
        ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset);

pread 호출은 lseek를 호출 후 read를 호출한 것과 동일한 효과를 내지만 다음과 같은 차이를 보인다. pwrite도 lseek 호출 후 write를 호출한 것과 동일한 효과를 갖는다. </br>
1. pread의 연산을 도중에 가로챌 수 없다.
2. 파일 포인터가 갱신되지 않는다.

파일 생성

open 함수에 O_CREAT와 O_EXCL을 지정하는 경우에도 원자적 연산이 일어난다. 두 옵션 모두 지정해서 open을 호출했을 때 파일이 이미 존재하고 있다면 open은 실패한다. </br>
하나의 연산이 여러 단계로 구성되어 있으며 그 단계들 모두가 수행되거나 아니면 하나도 수행되지 않음이 보장될 때를 원자적 연산이라 한다. </br>
원자적 연산에서는 일부 단계들만 수행되는 일이 생기지 않아야 한다. 

## 3.12 dup 함수와 dup2 함수

기존 파일 서술자를 복제할 때 사용한다.

        #include <unistd.h>

        int dup(int filedes);

        int dup2(int filedes, int filedes2);

dup가 돌려주는 새 파일 서술자는 사용 가능한 파일 서술자들 중 가장 낮은 번호임이 보장된다. </br>
dup2의 경우에는 filedes2 인수로 지정된 값이 새 파일 서술자의 값이 된다. filedes2가 이미 열려 있다면 dup2는 먼저 그것을 닫은 후에 복제한다. </br>
단, filedes가 filedes2와 같으면 filedes2를 닫지 않고 돌려준다.

## 3.13 sync 함수, fsync 함수, fdatasync 함수

UNIX 시스템의 전통적인 구현들에서 대부분 디스크 I/O 연산들은 커널 안의 버퍼 캐시 또는 패이지 캐시를 거친다. </br>
프로세스가 파일에 자료를 기록하면 보통의 경우 커널은 그 자료를 자신의 버퍼들 중 하나에 복사해서 내부적인 대기열에 등록해 두고, 나중에 적당한 시점이 되면 디스크에 기록함. (지연된 쓰기) </br>
언젠가는 커널이 지연된 쓰기 블록들을 모두 디스크에 기록하게 되는데, 보통은 버퍼를 다른 어떤 디스크 블록에 대해 재사용해야 할 때 그런 일이 일어난다. </br>
UNIX 시스템은 디스크상의 파일 시스템과 버퍼 캐시의 내용 간에 일치를 보장하기 위해 sync, fsync, fdatasync 함수를 제공함.

sync 함수는 수정된 쓰기용 블록 버퍼들을 모두 대기열에 등록한 후 반환된다. 이 함수는 디스크 기록 연산들이 완료될 때까지 기다리지 않는다. </br>
fsnyc 함수는 filedes로 지정된 파일 서술자에 해당하는 하나의 파일에만 작용한다. 이 함수는 디스크 쓰기들이 완료될 때까지 기다렸다가 반환된다. </br>
수정된 블록들이 디스크에 실제로 기록되었음을 보장할 필요가 있는 응용 프로그램을 위해 만들어진 것이다. </br>
fdatasync 함수는 fsync와 비슷하되 파일의 자료 부분들에만 영향을 미친다. 반면 fsnyc 함수는 파일의 특성들도 동기적으로 갱신한다.

## 3.14 fcntl 함수

fcntl 함수를 이용하면 이미 열려 있는 파일의 특성들을 변경할 수 있다.
        #include <fcntl.h>

        int fcntl(int filedes, int cmd, ... /* int arg */);

fcntl 함수는 다음과 같은 서로 다른 다섯 가지 용도로 쓰인다. </br>
1. 기존 파일 서술자를 복제한다. (cmd = F_DUPED)
2. 파일 서술자 플래그들을 조회, 설정한다. (cmd = F_GETFD 또는 F_SETFD)
3. 파일 상태 플래그들을 조회, 설정한다. (cmd = F_GETFL 또는 F_SETFL)
4. 비동기 I/O 소유권을 조회, 설정한다. (cmd = F_GETOWN 또는 F_SETOWN)
5. 레코드 자물쇠를 조회, 설정한다. (cmd = F_GETLK 또는 F_SETLK 또는 F_SETLKW)

F_DUPED: filedes로 지정된 파일 서술자를 복제한다. 함수는 새 파일 서술자를 돌려준다.
F_GETFD: filedes로 지정된 파일 서술자의 파일 서술자 플래그들을 함수의 반환값으로 돌려준다.
F_SETFD: filedes로 지정된 파일 서술자의 파일 서술자 플래그들을 설정한다. 새 플래그 값은 셋째 인수로 지정한다.
F_GETFL: filedes로 지정된 파일 서술자의 파일 상태 플래그들을 함수의 반환값으로 돌려준다. 
F_SETFL: 파일 상태 플래그들을 셋째 인수로 설정한다. 변경할 수 있는 플래그들은 O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, O_ASYNC 뿐이다.
F_GETOWN: 현재 SIGURG 신호와 SIGIO 신호를 받도록 설정되어 있는 프로세스 ID나 프로세스 그룹 ID를 조회한다.
F_SETOWN: 프로세스 ID나 프로세스 그룹 ID가 SIGIO 신호와 SIGURG 신호를 받도록 설정한다.

fcntl의 반환값은 명령에 따라 다르고 모든 명령은 오류 시 -1을 돌려주고 성공 시 그외의 어떤 값을 돌려준다.

## 3.15 ioctl 함수

이전에 배운 함수들로 할 수 없는 일을 만나면 ioctl의 힘을 빌릴 수 밖에 없다. 특히 터미널 I/O에서 이 함수가 즐겨 쓰인다.
        #include <unistd.h>        /* System V */
        #include <sys/ioctl.h>     /* BSD와 Linux */
        #include <stropts.h>       /* XSI STREAMS */

        int ioctl(int filedes, int request, ...);

## 3.16 /dev/fd

최근의 시스템들은 /dev/fd라는 이름의 디렉토리를 제공함. 0,1,2와 같은 이름의 파일들이 들어 있다. /dev/fd/n이라는 파일을 여는 것은 파일 서술자 n을 복제하는 것과 동일함.

        fd = open("/dev/fd/o", mode);
        fd = dup(0);
        fd = open("/dev/fd/0", O_RDWR);
/dev/fd의 한 파일을 pathname 인수에 지정해서 creat를 호출하는 것도 가능하며, 마찬가지로 그러한 경로이름과 O_CREAT를 지정해서 open을 호출하는 것도 가능하다.
